---
output: html_document
editor_options: 
  chunk_output_type: console
---
output: html_document
---
editor_options: 
  chunk_output_type: console
---
  title: "Architecture chart"
author: "Hendrik Sabert"
date: "20/02/2020"
output:
  html_notebook:
  fig_height: 8
  fig_width: 11
code_folding: show
html_document:
  df_print: paged
editor_options: 
  chunk_output_type: console
---

# Initialisation

```{r Initialisation - Settings, load data}

# Libraries ---------------------------------------------------------------------------------------------------------------------

library(data.table)
library(readxl)
library(bit64)
library(grid)
library(gridExtra)
library(jsonlite)
library(shiny)
library(tidyr)
library(digest)
library("RColorBrewer")


rm(list = ls())

# Settings ----------------------------------------------------------------------------------------------------------------------

settings <-list(indication    = c("DIA Japan", "DIA US", "OBE Japan", "MIG US", "MIG UK")[2],
                pathData      = "Data",
                pathTemp      = "Data",
                pathCoreData  = "core data.R",
                loadCoreData  = TRUE,
                runExamples   = TRUE,
                debug         = TRUE
               )


# Utility functions -------------------------------------------------------------------------------------------------------------

# Conversion of 64bit vectors to bit arrays

int64ToBitArray <- function(v, bits=60, drop=F){                                # Convert 64-bit integer vector into bit arrays
  m <- matrix(0L, nrow=length(v), ncol=bits)                                    # to store months-by-month flag data efficiently 
  n <- which(v>0)
  v <- v[n]
  for (i in 0:3){                                                               # split 64-bit vector into 16 bit chunks
    k <- 0x10000                                                                # (no bitwise boolean for int64 or uint32?)
    b <- as.integer(v %% k)
    v <- v %/% k
    k <- 1
    for (j in 0:15){
      l <- 16L*i+j+1L 
      if (l > bits) break
       m[n,l] <- bitwAnd(b,k)>0
      k <- k*2
    } 
  }
  if (drop) m <- drop(m)                                                         # If drop==T, return vector for single numbers
  return(m)                                                            
}

# Conversion of bit arrays to 64bit vectors ------------------------------------

bitArrayToInt64 <- function(m){                                                 # Convert bit array into64-bit integer vector
  if (class(m)[1] %in% c("numeric", "integer")){
    m <- t(as.matrix(m))
  } 
 k <- ncol(m)
 n <- integer64(length=nrow(m))
 for (i in k:1){
   n <- n * 2L
   n <- n + (m[,i, drop=T]>0)
 }
 return(n)
}

# Extract single bit column from integer64 -------------------------------------

int64ToBitVector <- function(v, bit=1){                                         # Extract single bit column from integer64 vector
  return(as.integer((v %/% (2L^(bit-1L))) %% 2L))
}

int64ToBitVectors <- function(i, from=1, to=60){                                # Extract range of columns (max 31)
  if((to-from)>31) {
    warning("Selection of >31 bits not possible. Returns int")
    return(NULL)
  } else {
    i <- i %/% (2L^(from-1L))
    return(as.integer(i %% (2L^(to-from+1L))))
  }
}

# Convert int64 numbers to string of 0 and 1 -----------------------------------

int64ToString <-function(v, sep=12, len=60, rev=TRUE){                          # Optionally reverse order               
  a <- as.bitstring(v)
  a <- substr(a,65-len,64)
  if(rev){
    a <- sapply(lapply(strsplit(a, NULL), rev), paste, collapse="")
  }
  if(!is.null(sep) && sep>0){
    a <- gsub("(.{12})(?!$)", "\\1-", a, perl = T)
  }
  return(a)
}

# Reverse bit order of int64 ---------------------------------------------------

int64InvertBitOrder <- function(k, bits=60){
  sel <- k>0
  j <- integer64(length(k))
  for (i in 1:bits){
    if(length(k)>=1e7) cat(".")
    j[sel] <- j[sel]*2L + int64ToBitVector(k,i)
  }
  if(length(k)>=1e7) cat("\n")
  return(j)
}

# Column sum of int64 (count of events by month) -------------------------------

bitVectorColsums <- function(k, plot=F, title=NULL){
  
  n0 <- length(k)
  k <- k[k>0]
  j <- integer(60)
  for (i in 1:60){
    if(length(k)>=1e7) cat(".")
    j[i] <- sum(int64ToBitVector(k,i))
  }
  if(plot){
    barplot(j, las=1, border=NA, cex.axis = 0.8, cex.names = 0.8, 
            names.arg = 1:60, xlab="Month", main=title)
  }
  if(length(k)>=1e7) cat("\n")
  return(j)
}

# Shorten data table to Top n rows ---------------------------------------------

topn <- function(df, n=5, pad=TRUE){
  df<- copy(df)
  cn <- which(sapply(df, is.numeric))
  df <- df[order(rowSums(df[,..cn]), decreasing=TRUE)]

  if(nrow(df)>n+1){
    v <- colSums(df[(n+1):nrow(df),..cn])
    set(df, as.integer(n)+1L, cn, as.list(v))
    cn <- setdiff(1:ncol(df),cn)
    set(df, as.integer(n)+1L, cn, as.list(rep("Other", length(cn))))
    df <- df[1:(n+1L),]
  }else
  if(pad && nrow(df)<n){
    l <- rep(NA, ncol(df))
    for(i in 1:(n-nrow(df))){
      df<-rbind(df, as.list(l))
    }
  }
  return(df)
}

# Report size of environment ---------------------------------------------------

environmentSize <- function(e, detail=T){                                       # Return size of objects in an environment
  i <- sort(sapply(mget(ls(envir = e), envir = e),object.size), decreasing = T)
  if(detail) return(i) else return(sum(i)/(2^30))
}

# Send message via iMessage ----------------------------------------------------

sendMessage <- function(msg) {
  
  # Remove double and single quotes since they might be open if partial lines are send 
  msg <- gsub("'", "", msg)
  msg <- gsub('"', "", msg)

  #Sends imessage (recipient has to have received at least one message sent manually!)
  recipient <- globalSettings$msgRecipient
  openApp <- "open /Applications/Messages.app -g"
  sendText <- paste("osascript -e \'tell application \"Messages\" to send \"", msg, 
                    "\" to buddy \"", recipient, "\" of (1st service whose service type = iMessage)\'", sep="")
  system(openApp)
  system(sendText)
}

# Debug printing and logging  --------------------------------------------------

dbprint <- function(msg, useprint=FALSE,...){                                       # XXX Add logging functionality
  if(!is.null(settings$debug) && settings$debug==TRUE){
    if(length(msg)<=1 && class(msg)[1] == "character" && !useprint)
      cat(paste0(msg),"\n")
    else
      print(msg, quote=FALSE,...)
  }
} 

# Plotting support function ----------------------------------------------------

headerLine <- function(text="", x=0, y=1){
  opar <- par(no.readonly = T)
  par(mar=c(5,4,4,2), oma=c(0,2,0,0))
  mtext(text, at=grconvertX(x, "nfc"), 
        side=3, line = y, cex=1.2, font = 2, adj = 0)
  par(opar)
}

footerLine <- function(text="", x=0, y=0, cex=0.8, source=FALSE){
  opar <- par(no.readonly = T)
  par(mar=c(2,4,4,2), oma=c(0,2,0,0))
  mtext(text, at=grconvertX(x,"nfc"),
        side = 1,  line=y, cex=cex, col="gray50", adj = 0)
  if(source %in% TRUE){
    l <- ""
    if((!is.null(e$info$indication))) l<-e$info$indication
    if((!is.null(e$info$dataVersion))) l<-paste0(l,", ",e$info$dataVersion)
    if(l=="") l<-"<source>"
    mtext(l, at=grconvertX(1.0,"npc"),
          side = 1,  line=y, cex=cex, col="gray50", adj =1)
  }
  par(opar)
}

annotation <-function(labels="XXX", 
                      x=0.8, y=0.1, 
                      col="gray50", coord="npc", cex=0.9, adj=0){
    text(x=grconvertX(x, coord), 
         y=grconvertY(y, coord), 
         labels = labels,
         col=col, cex=cex, adj = adj, xpd=T
        )
}

# Clear working environment ----------------------------------------------------

clearEnvironment <- function(savelist=NULL, retainFunctions=TRUE){
  if(!is.null(savelist)){
    objectsToRetain <- union(objectsToRetain, savelist)
  }
  if(retainFunctions){
    objectsToRetain <- union(objectsToRetain, lsf.str())
  }
  rm(list=setdiff(ls(envir = .GlobalEnv), objectsToRetain), envir = .GlobalEnv)
}

# Load Core Data ---------------------------------------------------------------

if(settings$loadCoreData){
  fn <- with(settings, paste(pathData, indication,
                             paste(indication, pathCoreData), sep="/"))
  if(file.exists(fn)){
    dbprint(paste0("Loading core data: '", fn,"'"))
    e <- new.env()
    load(file = fn, envir = e)
  }else{
    stop(paste0("File '", fn, "' not found"))
  }
  rm(fn)
}

# List of objects not to clear -------------------------------------------------

objectsToRetain <- union(ls(), "objectsToRetain")                               # Objects not to delete when clearing global environment

```

# Pre-process data

```{r Data preparation - Drug Histories table to R data set}

# -------------------------------------------------------------------------------------------------------------------------------
# Generate stock-table, stock and flow summaries, and optionally Rx-bit vectors 
# Results saved in working environment 'e'
# -------------------------------------------------------------------------------------------------------------------------------

conf <- list(
  pathEntities                 = "Entities.xlsx",
  generateRxVectors            = TRUE,
  generateRxClassVectors       = TRUE,
  generateRxGroupVectors       = TRUE,
  removeEmptyVectors           = TRUE,
  attachOrderDigest            = TRUE,
  defaultStockCol              = rgb(1.0,1.0,0.0),
  defaultDrugCol               = rgb(0.5,0.5,1.0),
  defaultDrugClassCol          = rgb(0.5,0.5,1.0),
  defaultDrugGroupkCol         = rgb(0.5,0.5,1.0),
  includeAllSocdem             = TRUE,
  saveTempFile                 = TRUE,
  saveResults                  = TRUE,                                          # Save results when done
  debug                        = TRUE
)

# Prepare data -----------------------------------------------------------------

e <- new.env()                                                                  # Container for results

# Read entity file

fn  <- paste(settings$pathData, settings$indication,
             paste(settings$indication, conf$pathEntities), sep="/")
if(!file.exists(fn)) stop("Entities file not found!")
a <- read_xlsx(path=fn,sheet = "Info", skip=3, col_types = "text", trim_ws = TRUE)
a <- as.data.table(a)
a <- a[apply(!is.na(a),1,any),]
a$value <- gsub('^(\")|(\")$',"", a[,value])

# Info items

e$info <- list()                                                                # XXX Add more completeness checking
for(i in a$item){
  e$info[[i]] <- a[item==i,value]
}
e$info$entities <- a                                                            # Store entire entities table
e$info$conf     <- conf                                                         # Store configuration for data preparation

l <- a[item=="dataLastMonth", value][1]
if(!is.null(l) && grepl("^[0-9]{2}/[0-9]{4}$",l)){                              # Regularize last months of data format
  e$info$dataLastMonth <- sprintf("%02s/%02s", 
                                          as.integer(substring(l,1,2)), 
                                          as.integer(substring(l,4,7))
                                         )
}else{
  stop("Last month of data not set or format incorrect!")                       # Stop if not provided
}

if(!is.null(e$info$pweightScaleFactor)){
  e$info$pweightScaleFactor <- as.numeric(e$info$pweightScaleFactor)
  if(e$info$pweightScaleFactor!=1.0){
    warning(sprintf("Patient weight scale factor will be applied! (%1.5f)",
                    e$info$pweightScaleFactor))
  }
}else{
  e$info$pweightScaleFactor <- 1.0
}

# Drugs, Drug Classes and Drug Groups

drugs         <- as.data.table(read_xlsx(fn,sheet = "Drugs", skip=3))
drugClasses   <- as.data.table(read_xlsx(fn,sheet = "Drug classes", skip=3))
drugGroups    <- as.data.table(read_xlsx(fn,sheet = "Drug groups", skip=3))
stocks        <- as.data.table(read_xlsx(fn,sheet = "Stocks", skip=3))

drugs$drug_id             <- as.integer(drugs$drug_id)                          # Make sure index columns are type integer
drugs$drug_group_id       <- as.integer(drugs$drug_group_id)                    # In case spreadsheet format is text
drugs$drug_class_id       <- as.integer(drugs$drug_class_id)
drugClasses$drug_class_id <- as.integer(drugClasses$drug_class_id)
drugGroups$drug_group_id  <- as.integer(drugGroups$drug_group_id)
stocks$id_numeric         <- as.integer(stocks$id_numeric)

drugs$rname        <- tolower(gsub("\\s+",".", drugs$generic_name))             # R-version of names, e.g. for naming columns
drugClasses$rname  <- tolower(gsub("\\s+",".", drugClasses$drug_class))
drugGroups$rname   <- tolower(gsub("\\s+",".", drugGroups$drug_group))

names(drugs)       <- tolower(gsub("(\\s+|[.])","_",trimws(names(drugs))))      # Regularize column names
names(drugClasses) <- tolower(gsub("(\\s+|[.])","_",trimws(names(drugClasses))))
names(drugGroups)  <- tolower(gsub("(\\s+|[.])","_",trimws(names(drugGroups))))
names(stocks)      <- tolower(gsub("(\\s+|[.])","_",trimws(names(stocks))))

fc <- function(v,missing="#FFFFFF"){                                            # Regularize and assign colors where missing
  for(i in 1:length(v)){                                                        # XXX Add ability to interpret wildcards
    if(is.na(v[i])){
      v[i] <- missing
    }else
    if(is.na(strtoi(gsub("#","0x",v[i])))){                                     # Interpretable as hex number? (#000000)
      v[i] <- paste0("rgb", gsub('\\"',"",v[i]))                                # if not try prepening "rgb" and evaluate
      try(v[i] <- as.character(eval(parse(text=v[i]))), silent = TRUE)          # as R expression
      if(is.na(strtoi(gsub("#","0x",v[i])))){
        v[i] <- missing
      }  
    }
  }
  return(v)
}

stocks$plot_colour      <- fc(stocks$plot_colour,     conf$defaultStockCol)
drugs$plot_colour       <- fc(drugs$plot_colour,      conf$defaultDrugCol)
drugClasses$plot_colour <- fc(drugClasses$plot_colour,conf$defaultDrugClassCol)
drugGroups$plot_colour  <- fc(drugGroups$plot_colour, conf$defaultDrugGroupkCol)
rm(fc, fn)

i <- match(drugs$drug_class, drugClasses$drug_class)
if(!all(i == drugs$drug_class_id)){
  warning("Drug Class IDs  in drug table appear incorrect. Looking up again")
}
if(!any(is.na(i))){
  drugs$drug_class_id <- i                                                      # Also makes sure ID is integer
}else{
  stop("Drug table contains drug classes not in drug classes table")
}
i <- match(drugs$drug_group, drugGroups$drug_group)
if(!all(i == drugs$drug_group_id)){
  warning("Drug Group IDs in drug table appear incorrect. Looking up again")
}
if(!any(is.na(i))){
  drugs$drug_group_id <- i                                                      # Also makes sure ID is integer
}else{
  stop("Drug table contains drug groups not in drug classes table")
}
i <- c("drug_id", "generic_name", "ndc", "drug_group", "drug_group_id", 
      "drug_class", "drug_class_id", "plot_colour")
if(!all(i %in% names(drugs))){
  stop(paste("Drugs table is missing columns: ", 
             paste(setdiff(i,names(drugs)), collapse = ", ")))
}

i <- c("drug_class_id", "drug_class", "display_name", "short_name", "plot_colour")
if(!all(i %in% names(drugClasses))){
  stop(paste("Drug Classes table is missing columns: ", 
             paste(setdiff(i,names(drugClasses)), collapse = ", ")))
}

i <- c("drug_group_id", "drug_group", "display_name", "short_name", "plot_colour")
if(!all(i %in% names(drugGroups))){
  stop(paste("Drug Groups table is missing columns: ", 
             paste(setdiff(i,names(drugGroups)), collapse = ", ")))
}

i <- c("id", "id_numeric", "box_code", "display_name", "short_name", 
       "drug_group", "plot_colour")
if(!all(i %in% names(stocks))){
  stop(paste("Stocks table is missing columns: ", 
             paste(setdiff(i,names(stocks)), collapse = ", ")))
}

e$en <- list()                                                                  # Move to data environment
e$en$drugs       <- drugs
e$en$drugClasses <- drugClasses
e$en$drugGroups  <- drugGroups
e$en$stocks      <- stocks
rm(i)

if(conf$debug){
  dbprint(strrep("-",80))
  dbprint(sprintf("Specification contains %1d drugs in %1d classes and %1d groups",
                  nrow(drugs), nrow(drugClasses), nrow(drugGroups)))
  dbprint(strrep("-",80))
  dbprint(drugs[,.(drug_id, generic_name, drug_class, drug_group)],
          topn=min(100,nrow(drugs)))
  dbprint(strrep("-",80))
}

# Load Patient movement table --------------------------------------------------

fn  <- paste(settings$pathData, settings$indication, 
             e$info$pathDrugHistories, sep="/")
if(file.exists(fn)){
  dbprint(paste("Loading Drug Histories data:",fn))
  d0 <-fread(file=fn)
}else{  
  stop(paste0("Drug Histories file '",fn,", not found!"))
}
if(!all(as.integer(gsub("month","",tail(colnames(d0),60)))==1:60)){
  stop("Column order of drug histories not as expected!")
}

i <- grep("disease", names(d0), ignore.case = TRUE)                             # Delete indication column if present
if(length(i)>0 && i %in% 1:ncol(d0)) d0[[i]] <- NULL

setnames(d0,1:2,c("patient", "pweight"))
d0[,"patient":=as.character(patient)]
setkey(d0,patient)
setnames(d0,3:62,sprintf("M%02d",1:60))

# Create table of unique patients, projection weights and soc-dem data ---------

fn  <- paste(settings$pathData, settings$indication, 
             e$info$pathPatientData, sep="/")
if(file.exists(fn)){
  dbprint(paste("Loading patient data:",fn))
  a <-fread(file=fn)
  nn <- c("patid", "weight", "age", "gender")
  
  if(!all(nn %in% names(a))){
    stop("Projection weigth, age or gender data missing!")
  } else{
    if(conf$includeAllSocdem){
      nn <- names(a)[order(match(names(a), nn))]
    }
    e$pt <- a[,as.list(mget(nn))]
    e$pt <- e$pt[,patid := as.character(patid)]
    setnames(e$pt, "patid", "patient")
    setnames(e$pt, "weight", "pweight")
    setkey(e$pt, patient)
    rm(fn,a,nn)
    if(!all(e$pt$patient %in% d0$patient)){
      warning("Patient IDs found in socdem data that are not in patient table!")
    }
    if(!all(d0$patient %in% e$pt$patient)){
      warning("Patient IDs found in patient table that are not in socdem data!")
    }
    if(!all(e$pt$gender %in% c("M","F",""))){
      warning("Gender tags other than M and F found!")
    }
    if(sum(e$pt$age>100) + sum(e$pt$age<1)>0){
      warning("Age tags outside of 1..100 range found!")
    }
  }
}else{  
  warning(paste0("Patient data file '",fn,", 
                 not found! Using data from drug histories."))
  e$pt <- d0[,.(patient=patient, pweight=pweight)]
  setkey(e$pt,"patient")
}

write.csv(e$pt,file = "pt.csv")

e$pt$pweight <- e$pt$pweight * e$info$pweightScaleFactor                        # Apply weight scale factor if present

d0$pweight <- NULL
e$info$ptHash <- digest(e$pt$id,"md5")
if(conf$attachOrderDigest){
  attributes(e$pt$patient)$digest.order <- e$info$ptHash
}  

# Check drug histories and patient table formats -------------------------------

if(nrow(d0)!=nrow(e$pt)) {
  stop("Number of entries in patient and drug history tables do not match!")
}else
if(!all(d0$patient==e$pt$patient)){
  stop("Patient IDs or odering in patient and drug history tables do not match!")
}else{
  dbprint("Drug history table format appears correct!")
}

# Generate stock table ---------------------------------------------------------

# Look-up table: stock_id -> drug_id

lu <- list()                                                                    # List of drugs per stock, used when looking up
n <- 0L:max(stocks$id_numeric)                                                  # Primary and secondary drugs for change table
for(i in n){
  l <- trimws(strsplit(stocks[id_numeric==i,drug_group],",")[[1]])
  lu[[i+1]] <- integer(0)                                                       # Length of output->0 if no drug! (lapsed, naive)
  if(all(l %in% drugGroups$drug_group)){                                        # and not "0", i.e. length==1
    for(j in 1:length(l)){
      lu[[i+1]] <- c(lu[[i+1]], drugs$drug_id[drugs$drug_group==l[j]])
    }
  }  
}
stockIdTodrugLU <- lu

# Look-up table: drugs_id -> drug_group_id

i <- 0L:max(drugs$drug_id)                                                      # Ordered by drug_id, not drug_id count!
lu <- drugs[match(i,drug_id),drug_group_id]                                     # Position 1: drug_id 0 (no drug, no drug_group)
lu[is.na(lu)] <- 0L                                                             # XXX: check if correct (non-existing drug_id)
if(length(lu)!= nrow(drugs)+1){
  stop(sprintf("Drug LU table (%1d) not consistent with number of drugs (%1d)", 
               length(lu)-1, nrow(drugs)))
}
drugidTodruggroupidLU <- lu

rm(lu,i,n,l,j)

# Assignment of patient to stocks based on drugs -------------------------------

fn  <- paste(settings$pathData, settings$indication,                            # Create assignment function from definition in Entities file
             paste(settings$indication, conf$pathEntities), sep="/")
a <- read_xlsx(path=fn,sheet = "Assignment", skip=3, col_types = "text")        # Read function definition 
a <- gsub("\n","",a)                                                            # Remove newline XXX: Check this works on PC!
a <- strsplit(a,"\r")[[1]]                                                      # Split into lines
a <- c("drugToStock<-",a)                                                       # Add function object

fn  <- paste(settings$pathTemp,"tempFunc.R", sep="/")                           # Save text definition as temp file 
f <- file(fn)                                                                   # (direct conversion from string appears to fail due to char limit)
writeLines(a, f)
close(f)
eval(parse(file = fn, keep.source = FALSE))                                     # Parse expression (creates drugToStock function)
file.remove(fn)
rm(f,a,fn)

if(!exists("drugToStock")){
  stop("Function to assign stocks could not be created!")
} 

if(conf$debug){
  dbprint(strrep("-",80))
  dbprint("Rule to assign stocks based on drugs")
  dbprint(strrep("-",80))
  dbprint(drugToStock)
  dbprint(strrep("-",80))
}

# Populate stock table ---------------------------------------------------------

s <- matrix(0L, nrow=nrow(e$pt), ncol = 60)

pp <- min(2500,as.integer(nrow(e$pt)/100))                                      # Interval for progress counter

for(n in 1L:nrow(e$pt)){                                                        # Main look to generate stock table

  if(n%%pp==1) dbprint(sprintf("%3.0f%%", n/nrow(e$pt)*100L))                   # Progress counter
  
  l <- strsplit(gsub("-","",d0[.(e$pt$patient[n]), M01:M60]),",", fixed = TRUE) # Convert sting with drugs to vectors by month
  j <- sapply(l, function(x) drugToStock(as.integer(x)))                        # Look up stock based on drugGroup [123us]
  j[j==0 & cumsum(j)>0] <- 1 
  k <- c(TRUE,sapply(2:60, function(x) setequal(l[[x]],l[[x-1]])))
  j[k] <- - j[k]
  if(any(is.na(j))) stop(sprintf("NAs found in stock table (n=%1d)",n))
  s[n,] <- j
}

e$s  <- s                                                                       # Move to e only now. Modifying s in e is slow!
e$s  <- cbind(e$pt$patient, data.table(e$s))
e$s  <- setNames(e$s, c("patient", sprintf("M%02d",1:60)))
rm(s)

if(conf$saveTempFile){
  fn <- paste(settings$pathTemp, "temp.R", sep = "/" )
  dbprint(paste0("Saving temp file (stock table): '",fn,"'"))
  save(list= "e", file = fn)
}

# Stock totals by month --------------------------------------------------------

dbprint("Generating table of stock totals by month")

i <- sort(e$en$stocks$id_numeric)
ns <- length(i)
e$ss <- data.table(
  entity        = rep(e$en$stocks$id[match(i, e$en$stocks$id_numeric)],2),
  stock_numeric = rep(i,2),
  type          = c(rep("n", ns),rep("pats",ns)), matrix(0,nrow=2*ns, ncol=60))
e$ss <- setnames(e$ss,4:63,sprintf("M%02d",1:60))
e$s$pweight <- e$pt$pweight

for(n in 1:60){
  k <- sprintf("M%02d",n)
  an <- e$s[,.(n=.N), keyby=abs(get(k))]
  an$type <- "n"
  ap <- e$s[,.(n=round(sum(pweight))), keyby=abs(get(k))]
  ap$type <- "pats"
  a <- rbind(an, ap)
  setnames(a,1,"stock_numeric")
  a <- a[e$ss,n,on=c("stock_numeric", "type")]
  a[is.na(a)] <- 0  
  e$ss[, sprintf("M%02d",n):= a]
}
rm(n,an,ap,a)

# Flow totals by month ---------------------------------------------------------

dbprint("Generating table of flow totals by month")

i <- sort(e$en$stocks$id_numeric)
ns <- length(i)
e$fs <- data.table(entity  = rep("",2*ns*ns),
                   from    = rep(i,each=ns),
                   to      = rep(rep(i,ns),2),
                   type   =  rep(c("n","pats"), each=ns*ns), 
                             matrix(0,nrow = 2*ns*ns, ncol=60)
                  )
e$fs <- setnames(e$fs, 5:64, sprintf("M%02d",1:60))
e$fs$entity <- paste0("F", e$en$stocks$id[match(e$fs$from,e$en$stocks$id_numeric)],
                      "_", e$en$stocks$id[match(e$fs$to,e$en$stocks$id_numeric)]
                     )

for(n in 2:60){
  k <- c(from=sprintf("M%02d",n-1L),to=sprintf("M%02d",n))
  l <- quote(list(from=abs(get(k[1L])), to=abs(get(k[2L]))))
  i <- e$s[, abs(get(k[1L]))!=abs(get(k[2L]))] | e$s[,get(k[2L])] > 1L
  an <- e$s[i,.(n=.N), keyby=eval(l)]
  an$type <- "n"
  ap <- e$s[i,.(n=round(sum(pweight))), keyby=eval(l)]
  ap$type <- "pats"
  a <- rbind(an, ap)
  a <- a[e$fs,n,on=c("from","to", "type")]
  a[is.na(a)] <- 0
  e$fs[, sprintf("M%02d",n):= a]
}

e$s$pweight <- NULL                                                             # Remove patient weights to save space

# Generate Rx-event vectors in integer64 vector format --------------------------------------------------------------------------

if(conf$generateRxVectors){

  drugs <- e$en$drugs[,.(drug_id, rname)]
  setkey(d0,patient)                                                            # Speed up selection of months in input data
  e$rx <- new.env()                                                             # Environment for Rx vectors

  if(!all(e$pt$patient==d0$patient)){
    stop("Patient IDs in input table (d0) and patient data don't match")
  }
  {
    dbprint(sprintf("Generating Rx-event vectors for %1d drugs:", nrow(drugs)))
    dbprint(strrep("-",60))
  }
  
  for(n in 1:nrow(drugs)){
    l <- integer64(length = nrow(e$pt))                                         # Create empty target vector
    for(i in 60:1){
      cat(".")
      k <- grepl(paste0("(^|,)\\s*",                                            # Get one bit slide from input table
                        sprintf("%1d",drugs$drug_id[n]),"\\s*(,|$)"),           # find target drugs, spaces ok
                        d0[, get(sprintf("M%02d",i))])                          # Comparison at string level (speed)
      l <- 2L * l + k                                                           # Move result to next bit-slot
    }
    cat("\n")
    cat(sprintf("%1d of %1d: %1s (id=%1d), n=%1d (%1.1f%% of patients)\n", 
       n, nrow(drugs),drugs$rname[n],drugs$drug_id[n],
       i<-sum(l>0), i/length(l)*100))
    class(l) <- c("event.ordered", "integer64")                                 # Assign class and inheritance
    if(conf$attachOrderDigest){
      attributes(l)$digest.order <- attributes(e$pt$patient)$digest.order
    }
    if(!(conf$removeEmptyVectors && sum(l>0)==0)){                              # Drop if empty
      assign(paste0("rx_", drugs$rname[n]),l,envir = e$rx)
    }
  }
  rm(n,i,k,l)

  if(conf$saveTempFile){
    fn <- paste(settings$pathTemp, "temp.R", sep = "/" )
    dbprint(paste0("Saving temp file (rx-vectors): '",fn,"'"))
    save(list= "e", file = fn)
  }
}

# Generate Rx-class event vectors -----------------------------------------------------------------------------------------------

if(conf$generateRxClassVectors){
  
  drugClasses <- e$en$drugClasses[!(drug_class %in% c("lapsed", "naive")), 
                                  .(drug_class, drug_class_id, rname)]
  {
    dbprint(sprintf("Generating Rx-event vectors for %1d drugs classes:", 
                    nrow(drugClasses)))
    dbprint(strrep("-",60))
  }

  for(n in 1:nrow(drugClasses)){
    d <- e$en$drugs[drug_class==drugClasses$drug_class[n], rname]
    l <- integer64(length = nrow(e$pt))                                         # Create empty target vector
    for (j in 60:1){
      cat(".")
      m <- integer(length = nrow(e$pt))
      for (k in 1:length(d)){
        a <- paste0("rx_", d[k])
        if(exists(a, envir = e$rx)){
          m <- m + int64ToBitVector(get(a, envir = e$rx),j)
        }  
      }
      l <- 2L*l + (m>0)
    }
    cat("\n")
    cat(sprintf("%1d of %1d: %1s (id=%1d), n=%1d (%1.1f%% of patients)\n", 
       n, nrow(drugClasses),drugClasses$drug_class[n],
       drugClasses$drug_class_id[n], i<-sum(l>0), i/length(l)*100))
    class(l) <- c("event.ordered", "integer64")                                 # Assign class and inheritance
    if(conf$attachOrderDigest){
      attributes(l)$digest.order <- attributes(e$pt$patient)$digest.order
    }
    assign(paste0("rxclass_", drugClasses$rname[n]),l,envir = e$rx)  
  }
  cat("\n")
}

# Generate Rx-group event vectors -----------------------------------------------------------------------------------------------

if(conf$generateRxGroupVectors){

  drugGroups <- e$en$drugGroups[!(drug_group %in% c("lapsed", "naive")), 
                                  .(drug_group, drug_group_id, rname)]
  {
    dbprint(sprintf("Generating Rx-event vectors for %1d drugs groups:", 
                    nrow(drugGroups)))
    dbprint(strrep("-",60))
  }

  for(n in 1:nrow(drugGroups)){
    d <- e$en$drugs[drug_group==drugGroups$drug_group[n], rname]
    l <- integer64(length = nrow(e$pt))                                         # Create empty target vector
    j <- 60
    for (j in 60:1){
      cat(".")
      m <- integer(length = nrow(e$pt))
      for (k in 1:length(d)){
        a <- paste0("rx_", d[k])
        if(exists(a, envir = e$rx)){
          m <- m + int64ToBitVector(get(a, envir = e$rx),j)
        }  
      }
      l <- 2L*l + (m>0)
    }
    cat("\n")
    cat(sprintf("%1d of %1d: %1s (id=%1d), n=%1d (%1.1f%% of patients)\n", 
       n, nrow(drugGroups),drugGroups$drug_group[n],
       drugGroups$drug_group_id[n], i<-sum(l>0), i/length(l)*100))
   
    class(l) <- c("event.ordered", "integer64")                                 # Assign class and inheritance
    if(conf$attachOrderDigest){
      attributes(l)$digest.order <- attributes(e$pt$patient)$digest.order
    }
    assign(paste0("rxgroup_", drugGroups$rname[n]),l,envir = e$rx)  
  }
  cat("\n")
}

# Summary ----------------------------------------------------------------------------------------------------------------------

if(conf$debug){
  dbprint(strrep("-",60))
  dbprint(paste0("Data summary         : ", e$info$indicationDisplayName))
  dbprint(strrep("-",60))
  dbprint(sprintf("Data period until    : %1s", e$info$dataLastMonth))
  dbprint(sprintf("Unique patient IDs   : %1d", nrow(e$pt)))
  dbprint(sprintf("Projected patients   : %1.0f", sum(e$pt$pweight)))
  dbprint(sprintf("Projection scaled by : %1.5f", e$info$pweightScaleFactor))
  if(!is.null(i<-attributes(e$pt$patient)$digest.order)){
    dbprint(paste("Patient order digest :", e$info$ptHash))
  } else{
    dbprint("Patient order digest not assigned")
  }
  dbprint(strrep("-",60))
} 

# Save results ------------------------------------------------------------------------------------------------------------------

if(conf$saveResults){
  fn <- with(settings, paste(pathData, indication, 
                             paste(indication, pathCoreData), sep="/"))
  if(conf$debug){
    dbprint(paste("Saving results - ", fn))
    dbprint(strrep("-",80))
    cat(sprintf("Total size: %1.3f GB\n", environmentSize(e,detail = F)))
    print(environmentSize(e,detail = T)/1e6, scientific=F, quote = FALSE)
    dbprint(strrep("-",80))
  }
  saveList <- ls(e)
  save(list = saveList, envir = e, file = fn)

  if(conf$saveTempFile){
    fn <- paste(settings$pathTemp, "temp.R", sep = "/" )
    if(file.exists(fn)) file.remove(fn)                                         # Delete file if it exists
  }
  
  clearEnvironment("e")
} 

```

```{r Data preparation - Examples and validation}

# Use of integer64 functions - Patient examples --------------------------------

{
  n <- sample(ls(e$rx),1)                                                       # Select random Rx vector
  v <- get(n, envir=e$rx)                                                       # Get Rx - vector
  p <- sample(which(v>0), size=1)                                               # Sample random patient with events from vector
  v <- v[p]
  id <- e$pt$patient[p]                                                         # Get patient ID
  dbprint(strrep("-",119))
  dbprint(paste("Patient             :", id, "Vector:",n))
  dbprint(strrep("-",119))
  dbprint(paste("Integer64 format    :",v))
  dbprint(paste("Integer64 bitstring :", as.bitstring(v)))
  dbprint(paste("Display bitstring   :", int64ToString(v)))
  dbprint("Convert to matrix   :")
  cat(as.vector(int64ToBitArray(v)))
  cat("\n")
  dbprint(strrep("-",119))
  if(exists("mapPatientHistoryIndividual")) mapPatientHistoryIndividual(id=id)
  if(exists("d0")) sapply(d0[patient %in% id,M01:M60],c)
  #rm(n,p,v,id)
}


# Compare Stock Table and drug changes to Mark's Box History table -------------

fn  <- paste(settings$pathData,settings$indication, 
             e$info$pathBoxHistories, sep="/")
d1 <-fread(file=fn)
d1[,"patient":=as.character(patient)]
d1$weight <- NULL
d1$disease <- NULL
setkey(d1,patient)
if(all(d1$patient == e$pt$patient)) print("Patient order consitent")

# Comparing patient sample 
ns <- 1000
n0 <- nrow(e$pt)
k  <- 0
l <- nchar(d1[1,month1])
e$en$stocks$box_code
for(n in sample.int(n0,ns)){
  if(n%%100==1) cat(".")
  j <- abs(e$s[n,M01:M60])
  j[j==1] <- 0
  if(!all(e$en$stocks$id_numeric[match(substr(d1[n,2:61],l,l),
                                       e$en$stocks$box_code)] %in% j)) k <- k+1
  if(k>0) stop()
  #if(!all((substr(d1[n,2:61],1,1)=="=") == (e$s[n,M01:M60]<1))) stop(n)
}
cat("\n")
dbprint(sprintf("%1d differences in sample of %1d patients",k,ns))
rm(ns,j)
  
# Comparing individual patients
{
  j <- " "
  #n <- sample.int(n0,1)
  dbprint(paste("Patient:", e$pt$patient[n]))
  dbprint(strrep("-",119), collaps="")
  dbprint(paste((as.integer(1:60/10)), collapse = " "))
  dbprint(paste((1:60)%%10, collapse = " "))
  dbprint(strrep("-",119), collaps="")
  dbprint(paste(abs(e$s[n,M01:M60]), collapse = " "))
  dbprint(paste(e$en$stocks$id_numeric[match(substr(d1[n,2:61],2,2),
                                 e$en$stocks$box_code)], collapse = " "))
  # dbprint(paste(ifelse(e$s[n,M01:M60]>0,"x",j), collapse = " "))
  # dbprint(paste(gsub("=",j, substr(d1[n,2:61],1,1)), collapse = " "))
}

# Check summaries and that stocks and flows are consistent ---------------------

nn <- "S03"                                                                     # Stock to test

m <- 2:60
n <- e$en$stocks$id_numeric[match(nn,e$en$stocks$id)]
a <- matrix(0, nrow=length(m),ncol=5)
i <- 1
for(i in 1:length(m)){
  a[i,1] <- sum(abs(e$s[[sprintf("M%02d",m[i])]])==n)                           # Re-calculate stock level and flows
  a[i,2] <- sum(e$fs[to==n   & type=="n",get(sprintf("M%02d",m[i]))])
  a[i,3] <- sum(e$fs[from==n & type=="n",get(sprintf("M%02d",m[i]))])
  a[i,4] <- sum((abs(e$s[[sprintf("M%02d",m[i]-1)]])!=n & abs(e$s[[sprintf("M%02d",m[i])]])==n) |
                (abs(e$s[[sprintf("M%02d",m[i]-1)]])==n & e$s[[sprintf("M%02d",m[i])]]==+n))
  a[i,5] <- sum((abs(e$s[[sprintf("M%02d",m[i]-1)]])==n & abs(e$s[[sprintf("M%02d",m[i])]])!=n) |
                (abs(e$s[[sprintf("M%02d",m[i]-1)]])==n & e$s[[sprintf("M%02d",m[i])]]==+n))
}  
colnames(a) <-c("s","fsi", "fso", "fi","fo")


s <- numeric(length=nrow(a))
s[1] <- a[1,1]
for(i in 1:(nrow(a)-1)){
  s[i+1] <- s[i]+a[i+1,"fi"]-a[i+1,"fo"]
}
ss <- as.numeric(e$ss[entity==nn & type=="n",M02:M60])

{
  dbprint(strrep("-",60))
  dbprint(paste(nn,"-",e$en$stocks$display_name[match(nn,e$en$stocks$id)]))
  dbprint(strrep("-",60))
  if(!identical(s,a[,1])){
    dbprint("ERROR: Actual and implied stocks inconsitent!")
    dbprint(a)
  }else{
    dbprint("Actual and implied stocks match!")
  }
  if(!identical(ss,s)){
    dbprint("ERROR: Stock table and summary stock table inconsitent!")    
    print(a, quote=FALSE)
  }else{
    dbprint("Stock table and summary stock table match!")
  }
  dbprint(strrep("-",60))
}  

# Plot actual stocks and stock implied by in and outflow

par(mfrow=c(1,2))
plot(a[,1], type = "l",ylim=c(0,max(s)), las=1, lwd=3, col="red",
     xlab="month", ylab="", main="Stock - Actual and implied ")
lines(s, lwd=1, col="blue")
lines(ss, lwd=1, col="yellow")

matplot(a[,2:5], type = "l", lty=1, las=1, ylab="", xlab = "month",
        main="Flows - Calulated and summary")
dbprint(a[,c(1,2,4,3,5)])
par(mfrow=c(1,1))

clearEnvironment()

```

```{r Data preparation - Additions to specific data sets}
  
saveResults <- TRUE

# US mortality data (CDC)
# Total  : https://ftp.cdc.gov/pub/Health_Statistics/NCHS/Publications/NVSR/71-01/Table01.xlsx
# Males  : https://ftp.cdc.gov/pub/Health_Statistics/NCHS/Publications/NVSR/71-01/Table02.xlsx
# Females: https://ftp.cdc.gov/pub/Health_Statistics/NCHS/Publications/NVSR/71-01/Table03.xlsx

if(settings$indication %in% c("DIA US", "MIG US")){
  
  dbprint("Adding US mortality data to data set (CDC data, 2020)")

  fn <- "Life table for the total population, United States 2020 (CDC).xlsx"
  fn <- paste(settings$pathData, settings$indication, "Source", fn, sep = "/")
  yr <- 1:100

  m <- data.table(age=yr)
  for(nn in c("Total", "Males", "Females")){
    suppressMessages(
      a  <- read_xlsx(path=fn, sheet=nn, skip = 2, )
    )
    setDT(a)
    setnames(a, 1 ,"age")
    a <- a[,age_band:= gsub("â€“","-", `age`)]
    a <- a[,.(age_band, qx=qx)]
    a <- a[match(sprintf("%1d-%1d", yr-1, m$age), age_band), ]
    a$age <- m$age
    m <- cbind(m, m[a, qx, on="age"])
    setnames(m, ncol(m),nn)
  }
  
  e$mort <- m
  rm(fn, a, yr, fn)

  if(settings$debug){
    dbprint(strrep("-",60))
    dbprint("US mortality")
    dbprint(strrep("-",60))
    dbprint(e$mort)

  }
}

# Save results -----------------------------------------------------------------

if(saveResults){
  
  fn <- with(settings, paste(pathData, indication, 
                             paste(indication, pathCoreData), sep="/"))
  if(settings$debug){
    dbprint(paste("Saving results - ", fn))
    dbprint(strrep("-",80))
    cat(sprintf("Total size: %1.3f GB\n", environmentSize(e,detail = F)))
    print(environmentSize(e,detail = T)/1e6, scientific=F, quote = FALSE)
    dbprint(strrep("-",80))
  }
  saveList <- ls(e)
  save(list = saveList, envir = e, file = fn)
  rm(saveResults, saveList)
} 

```

# Visualisation

```{r Visualisation - Architecture Map - Parse layout}

# Load and prepare market architecture layout 

parseLayout <- function(fn           = "layout.json", 
                        useValueTags = TRUE, 
                        debug        = TRUE
                        )
{
 
  layoutClass <- function(n){
    a <- rep("other", length(n))
    n <- toupper(n)
    a[grepl("^[S][0-9]+\\b",n)] <- "stock"
    a[grep("^F[SNG][0-9]+[_][SNG][0-9]+([_][0-9]+)*\\b", n)] <- "flow"
    a[grep("^N[0-9]+\\b", n)] <- "node"
    a[grep("^G[0-9]+\\b", n)] <- "group"
    return(a)
  }
  
  if(!file.exists(fn)){
    warning("File not found")
    return(NULL)
  }
  a <- fromJSON(paste(readLines(fn), collapse=""))

  shp <- list()                                                                 # Flatten first level groups
  for(i in 1:length(a)){                                                        # XXX Extremely inefficient
    if(a[[i]]$type == "group"){
      shp <- append(shp,a[[i]][!(names(a[[i]]) %in% c("type", "members"))])
    }else{
      j <- length(shp)+1
      shp[[j]] <- a[[i]]
      names(shp)[j] <- names(a)[i]
    }  
  }
  names(shp) <- trimws(toupper(names(shp)))                                     # Regularize case of shapes   

  ns <- table(names(shp))
  if(max(ns)>1){
    warning(paste(max(ns), "duplicate shape names found:", 
                  paste(names(ns)[ns>1], collapse = ", ")))
  }
  
  l <- list()                                                                   # Assign names, values and equations
  for(n in names(shp)){
    i <- strsplit(n,"\\s+")[[1]][1]
    l[[i]]$shapes[[n]] <- shp[[n]]
  }  
  for(i in 1:length(l)){
    n <- names(l)[i]
    l[[i]]$class <- layoutClass(n)
    j <- l[[i]][["shapes"]][[paste(n,"VALUE")]]                                 # Find value tag
    if(useValueTags && !is.null(j) && j$type=="textbox"){
      l[[i]]$value <- suppressWarnings(as.numeric(j$text))
    } else{
      l[[i]]$value <- NA                                                        # If no value tag assigned, NA   
    }
    j <- l[[i]][["shapes"]][[paste(n,"EQUATION")]]                              # Find equation tag
    if(!is.null(j) && j$type=="textbox"){
      l[[i]]$equation <- j$text            
    } else{                                                                     # If no equation tag assigned, NA
      l[[i]]$equation <- NA            
    }
    j <- l[[i]][["shapes"]][[paste(n,"NAME")]]                                  # Find name tag
    if(!is.null(j) && j$type=="textbox"){
      l[[i]]$name <- j$text
    } else{                                                                     # If no name tag assigned, NA
      l[[i]]$name <- NA            
    }
  }

  xm <- c(0,0)                                                                  # Determine min and max coordinates
  ym <- c(0,0)
  if(!is.null(l$FRAME$shapes$FRAME)){
    if(debug) dbprint("Frame found. Scaling to frame size\n")
    xm <- range(l$FRAME$shapes$FRAME$x)
    ym <- range(l$FRAME$shapes$FRAME$y)
    
  }else{
    if(debug) dbprint("No frame found. Using global min/max\n")
    i <- lapply(shp, "[[","x")
    xm <- range(sapply(i, "[",2))
    i <- lapply(shp, "[[","y")
    ym <- range(sapply(i, "[",2))
  }
  for(i in 1:length(l)){                                                        # Normalize shape coordinates
    if(!is.null(l[[i]]$shapes)){
      for(j in 1:length(l[[i]]$shapes)){
        l[[i]]$shapes[[j]]$x <-    (l[[i]]$shapes[[j]]$x-xm[1])/(xm[2]-xm[1])
        l[[i]]$shapes[[j]]$y <- 1- (l[[i]]$shapes[[j]]$y-ym[1])/(ym[2]-ym[1])
      }
    }
  }
  l$render$xm <- xm
  l$render$ym <- ym
  
  return(l)  
}

# Get layoyt symbols -----------------------------------------------------------

getLayoutSymbols <- function(layout, debug=FALSE){

  if(!is.list(layout)){
    warning("Layout not provided")
    return(NULL)
  }
  evalRecursive <- function(nn, n=1){                                           # Recursive lexical parsing
    if(is.expression(d[[nn]])){                                                 # No checking if expression resolve
      n <- n+1
      if(n>=10){
        stop(paste0("Iteration limit reached (n=",n,"), ",
                   "Circular definition for ",nn,"?"))
      } 
      i <- all.vars(d[[nn]])
      j <- sapply(i, exists, i,d)
      if(!all(j)){
        for(k in i[!j]) assign(k, 0, envir = d)
      }
      j <- sapply(i, function(x) is.expression(get(x,envir=d)))
      if(any(j)){
        for(k in i){
          evalRecursive(k,n=n)
        }
      }  
      d[[nn]] <- 2
    }
  }

  d <- new.env()
  i <- sapply(layout,function(x) ifelse(is.null(x$class), NA,x $class))         # Value driven elements in layout
  nn <- names(i)[i %in% c("stock", "flow", "node", "group")]
  
  for(n in 1:length(nn)){                                                       # Value or equation tags provided 
    eq <- layout[[nn[n]]]$equation
    eqexp <- NULL
    v  <- layout[[nn[n]]]$value
    if(is.character(eq) && eq!="") try(eqexp <- str2expression(eq))
    if(is.expression(eqexp)){
      assign(nn[n],eqexp, envir = d)
    } 
    else if(!is.null(v)){
      assign(nn[n],1, envir = d)
    }
  }

  i <- which(sapply(nn, function(x) is.expression(d[[x]])))                     # Recursive resolution of equation tags
  for(n in i){   
    evalRecursive(nn[n])
  }
  
  nn <- ls(d)                                                                   # Summary
  sym <- sapply(nn, function(x) c("missing", "given", "resolved")[d[[x]]+1])
  sym <- sym[order(sym, names(sym))]
  
  if(debug){
    if(sum(sym=="missing")>0){
      dbprint("Symbols used in equations but not defined:")
      dbprint(strrep("-",80), quote=FALSE)
      dbprint(paste(names(sym)[sym=="missing"], collapse = ", "))
    }
    cat("\n")
    dbprint("Symbols defined via equations and resolved:")
    dbprint(strrep("-",80), quote=FALSE)
    dbprint(paste(names(sym)[sym=="resolved"], collapse = ", "))
    cat("\n")
    dbprint("Symbols required to populate layout:")
    dbprint(strrep("-",80), quote=FALSE)
    l <- names(sym)[sym!="resolved" | sym=="missing"]
    dbprint(paste(l, collapse = ", "))
    
    if(exists("ss", envir = e) && exists("fs", envir = e)){
      cat("\n")
      dbprint("Symbols not available in data environment:")
      dbprint(strrep("-",80), quote=FALSE)
      dbprint(paste(setdiff(l, union(e$ss$entity, e$fs$entity)), 
                    collapse = ", "))
    }
    cat("\n")
  }
  
  if(debug>1){
    for(n in 1:length(sym)) print(sprintf("%-12s : %1s", names(sym)[n], sym[n])) 
  }  
  return(sort(names(sym)[sym!="resolved"]))
}  

# Examples ---------------------------------------------------------------------

if(settings$runExamples){
  
  fn <- paste(settings$pathData, settings$indication, "Source", sep="/")
  fn <- paste(fn, "Map template V05 - Slide2.json", sep="/")
  layout <- parseLayout(fn = fn)                                                 # Layout data (ppt export)
  invisible(getLayoutSymbols(layout, debug=TRUE))
}

```

```{r Visualisation - Architecture Map - Assign values}

assignLayoutValues <- function(layout, 
                               values             = list(),
                               defaultValue       = NA,
                               reuseLayoutValues  = TRUE, 
                               debug              = TRUE
                              )
{
  evalRecursive <- function(nn, n=1){
    if(is.expression(d[[nn]])){
      n <- n+1
      if(n>=10){
        stop(paste0("Iteration limit reached (n=",n,"), ",
                   "Circular definition for ",nn,"?"))
      } 
      i <- all.vars(d[[nn]])
      j <- sapply(i, exists, i,d)
      if(!all(j)){
        for(k in i[!j]){
          missingEvaluation <<- append(missingEvaluation, k)
          assign(k, defaultValue, d)
        }
      }
      j <- sapply(i, function(x) is.expression(get(x,envir=d)))
      if(any(j)){
        for(k in i){
          evalRecursive(k,n=n)
        }
      }  
      d[[nn]] <- eval(d[[nn]],envir=d)
    }
  }
  
  isValidNumber <- function(v){
    return(!is.null(v) && !is.na(v) && !is.infinite(v) && !(length(v)==0))
  }
  
  d <- new.env(parent = baseenv())                                              # Set up evaluation environment
  i <- sapply(layout,function(x) ifelse(is.null(x$class), NA, x$class))         # Value driven elements in layout
  nn <- names(i)[i %in% c("stock", "flow", "node", "group")]
  
  if(reuseLayoutValues){
    for(n in 1:length(nn)){                                                     # Populate values from layout
      v <- layout[[nn[n]]]$value
      if(!isValidNumber(v)) v <- NA
      assign(nn[n],v, envir = d)
    }
  }
  if(length(values)>0){
    list2env(values, envir = d)                                                 # Add passed values
  }
  
  eq <- sapply(nn, function(x) layout[[x]]$equation)                            # Add values defined via equations
  i <- which(is.character(eq) & eq!="")                                         # takes precedence over passed values
  for(n in i){
    assign(nn[n],str2expression(eq[n]), envir = d)
    if(!is.expression(d[[nn[n]]])){
      stop(sprintf("Invalid expression: %1s = %1s",nn[n], eq[n]))
    }
  }
  missingEvaluation <- list()                                                   # List of missing values
  for(n in i){                                                                  # Evaluate equations recursively
    evalRecursive(nn[n])
  }
  if(length(missingEvaluation)>0){
    i <- paste(unlist(missingEvaluation), collapse = ", ")
    j <- paste0(length(missingEvaluation), " symbols missing for evaluation of equations!")
    warning(paste0(j, "\n  (",i,")"))
    if(debug){
      dbprint(j)
      dbprint(strrep("-",50))
      dbprint(i)
      cat("\n")
    }  
  }
  
  if(debug){
    dbprint("Values assigned via Equation Tags:")
    dbprint(strrep("-",50))
    i <- which(is.character(eq) & eq!="")                                       # takes precedence over values
    for(n in i){
      if(isValidNumber(d[[nn[n]]])){
        dbprint(sprintf("%-3d: %-12s : %-8.0f %1s", n, nn[n], d[[nn[n]]], eq[n]))
      }
    }  
    dbprint("")
    dbprint("Values assigned via Value Tags:")
    dbprint(strrep("-",50))
    for(n in setdiff(1:length(nn),i)){
      j <- d[[nn[n]]]
      if(!isValidNumber(j)) j <- NA
      if(!is.na(j)){
        dbprint(sprintf("%-3d: %-12s : %1.0f", n,nn[n], j))
      }  
    }
  } 

  missingValues <- list()
  for(n in 1:length(nn)){                                                       # Populate values from layout
    v <- d[[nn[n]]]
    if(isValidNumber(v)){
      layout[[nn[n]]]$value <- v
    }else{
      missingValues <- append(missingValues, nn[n])
    } 
  }
  if(j <- length(missingValues)){
    if(debug){
      cat("\n")
      dbprint("Values required, but not available or derivable")
      dbprint(strrep("-",50))
      for(i in 1: length(missingValues))
        dbprint(paste(i,":",missingValues[i]))
      cat("\n")
    } else{
      i <- paste(unlist(missingValues), collapse = ", ")
      j <- paste0(j, " values required in layout not available or NA!")
      warning(paste0(j, "\n  (",i,")"))
    }
  }  
  return(layout)
}

# Reset layout Value Tags ------------------------------------------------------

resetLayoutValules <- function(layout, value = NA){
  i <- sapply(layout,function(x) ifelse(is.null(x$class), NA, x$class))         # Value driven elements in layout
  nn <- names(i)[i %in% c("stock", "flow", "node", "group")]
  
  val <- sapply(nn, function(x) layout[[x]]$value)
  
  for(n in names(val)){
    if(!is.null(layout[[n]]$value)){
      layout[[n]]$value <- value
    }  
  }
  return(layout)
}

# Examples ---------------------------------------------------------------------

# Assemble stocks and flow values  from data environment into input list
{
  projected <- TRUE
  period    <- 49:60
  
  m    <- sprintf("M%02d", period)
  proj <- if(projected) "pats" else "n"
  
  v <- rowMeans(e$ss[type==proj, ..m], na.rm = TRUE) /1000
  names(v) <- e$ss[type==proj, entity]
  values <- as.list(v)
  v <- rowMeans(e$fs[type==proj, ..m], na.rm = TRUE) / 1000
  names(v) <- e$fs[type==proj, entity]
  values <- append(values,v)
}
rm(m,proj,v)

# Adding missing equation ad-hoc
{
  layout$FS01_G01$equation <- "FS01_S02 + FS01_S03"
  layout$FS00_G01$equation <- "FS00_S02 + FS00_S03"
  layout$FS08_G01$equation <- "FS08_S02 + FS08_S03"
  layout$FN01_G01$equation <- "N01"
  layout$FS01_G02$equation <- "FS01_S04 + FS01_S05"
  layout$FS00_G02$equation <- "FS00_S04 + FS00_S05"
  layout$FS08_G02$equation <- "FS08_S05 + FS08_S06"
  layout$FS00_G03$equation <- "FS00_S06 + FS00_S07"
  layout$FN04_S08$equation <- "FS05_S08 + FS06_S08"
}
  
# Remove all existing value tags
layout <- resetLayoutValules(layout, value = NULL)

layout <- assignLayoutValues(layout,                                            # Layout from parser
                             values = values,                                   # List of new entity values
                             defaultValue = NA,                                 # Value if missing
                             reuseLayoutValues = FALSE,                         # Use/ignore values already in layout                 
                             debug = TRUE
                             )

if(exists("renderArchitectureMap")){
  renderArchitectureMap(layout = layout)
}

```

```{r Visualisation - Architecture Map - Render map}

renderArchitectureMap <- function(layout = NULL,
                                  header = NULL,
                                  footer = NULL,
                                  debug  = FALSE)
{

  vrangeStocks          <- "auto" # c(0,2000)                                   # Value range for stocks (NULL:min/max)
  vrangeFlows           <- "auto" #c(0,5000)                                    # Value range for stocks (NULL:min/max)
  mar                   <- c(1.0,1.0,1.5,1.0)*0.03                              # Margins to inner VP (0..1)
  fontScale             <- 0.70                                                 # Overall scaling of fonts
  showFrames            <- FALSE                                                # Show boundary of inner VP
  showIDs               <- FALSE                                                # Show names of architecture
  showEquations         <- FALSE
  showLabels            <- TRUE
  showArrowWidth        <- TRUE                                                 # Arrow width driven by value
  showStockLabels       <- c(TRUE,FALSE,"auto")[3]
  showFlowValues        <- c(TRUE,FALSE,"auto")[1]
  showFlowNames         <- c(TRUE,FALSE,"auto")[1]
  labelBackground       <- c("none", "plain", "cartouche")[3]
  defaultFlowValue      <- NULL
  defaultStockValue     <- NULL
  colStock              <- "gray60"                                             # Color of stock elements
  colStockFill          <- "lightblue"
  colStockTransp        <- 0.8
  colFlow               <- "gray70"                                             # Color of flow arrows
  colLabel              <- "gray10"                                             # Font color of labels
  colNode               <- "gray70"
  colID                 <- "blue"
  labelSize             <- 1.3
  nodeDiam              <- 0.015
  stockMaxLevel         <- 0.8
  stockLevelScaling     <- NULL                                                 # Function to scaling stock level (e.g. sqrt)
  stockValueLabelFormat <- "%1.0f"
  flowArrowMax          <- 10                                                   # Max width of flow arrows
  flowArrowScaling      <- sqrt                                                 # Function to scale linewidth (0..1 input)
  flowValueLabelFormat  <- "%1.0f"
  arrowLength           <- 0.01                                                 # Length of flow arrows (x)
  arrowGap              <- 0.2                                                  # Gap between arrow and box
  minArrowAngle         <- 10                                                   # Min arrow angle (width)

  if(is.null(layout) || !(class(layout) %in% c("list"))) stop("Layout not provided!")
  
  # Utility functions
  isValidNumber <- function(v){
    return (!is.null(v) && !is.na(v) && is.finite(v) && length(v)>0)
  }
  
  # Find minimum and maximum stock and flow values
  
  lc    <- lapply(layout, "[[", "class")
  lv    <- lapply(layout,"[[", "value")

  if(vrangeStocks=="auto"){
    suppressWarnings(vrangeStocks <- range(lv[lc=="stock"], na.rm = TRUE))
    if(any(!isValidNumber(vrangeStocks))) vrangeStocks <- c(0,1000) 
    if(is.null(defaultStockValue)) defaultStockValue <- max(vrangeStocks) / 4
    if(debug){
      print(sprintf("Value range for stocks not provided. Using min/max (%1.0f/%1.0f)",
          vrangeStocks[1], vrangeStocks[2]))
    }
  }  
  if(vrangeFlows=="auto"){
    vrangeFlows <- range(lv[lc=="flow"], na.rm = T)
    if(any(!isValidNumber(vrangeFlows))) vrangeFlows <- c(0,1000)
    if(is.null(defaultFlowValue)) defaultFlowValue <- max(vrangeFlows) / 4
    if(debug){
      print(sprintf("Value range for flows not provided. Using min/max (%1.0f/%1.0f)",
          vrangeFlows[1], vrangeFlows[2]))
    }
  }
  # Clear page and setup view ports

  grid.newpage()                                                                # Outer frame, leave margin

  if(!is.null(layout$render$xm)) xm <- layout$render$xm else xm <- c(0,1)       
  if(!is.null(layout$render$ym)) ym <- layout$render$ym else ym <- c(0,1)
  
  vp <-  viewport(x= unit(0.5, "npc"),
                  y= unit(0.5, "npc"), 
                  width = unit((xm[2]-xm[1])/(ym[2]-ym[1]), "snpc"), 
                  height = unit(1, "snpc"), 
                  gp = gpar(cex=fontScale),
                  name = "baseVP")
  pushViewport(vp)
  
  if(showFrames){
    grid.rect(0, 0, 1, 1, vjust = 0, hjust = 0,                                 # Frame around outer VP
            gp=gpar(col="grey80", fill=NA))
  }
  i <- min((1-mar[2]-mar[4]), (1-mar[1]-mar[3]))                                # Inner VP (apply margins)
  vpi <- viewport(x= unit(mar[2]+i/2, "npc"),
                  y= unit(mar[1]+i/2, "npc"), 
                  width  = unit(i, "npc"), 
                  height = unit(i, "npc"), 
                  gp = gpar(cex=fontScale),
                  name = "innerVP")
  pushViewport(vpi)
  
  aspr <- as.numeric(vp$width)  / as.numeric(vp$height) *                       # Overall aspect ratio
          as.numeric(vpi$width) / as.numeric(vpi$height)

  # Prepare shape list
  
  l <- unlist(unname(lapply(layout, "[[", "shapes")), recursive = F)            # Flat list of shapes
  sn <- names(l)                                                                # Shape names
  sz <- order(sapply(l, "[[", "zorder"))                                        # Z-order for rendering 
  sc <- sapply(sn, function(x) layout[[strsplit(x,"\\s+")[[1]][1]]]$class)

  # Render shapes
  
  for (n in sz){                                                                # Plot graphic elements
    x <- l[[n]]$x                                                               # Shape coordinates
    y <- l[[n]]$y
    snn <- strsplit(sn[n],"\\s+")[[1]]
    
    if(debug) dbprint(sprintf("%1s: %1s (z=%1d)", sn[n],sc[n],sz[n]))
    
    if(l[[n]]$type =="rectangle"){
      if(sc[n]=="stock"){
        if(snn[2] == "SYMBOL"){
          v <- layout[[snn[1]]]$value
          if(is.numeric(v)){
            col <- colStockFill
          } else{
            v <- defaultStockValue
            col <- rgb(1,0.5,0.5) 
          }
          v <- (v - vrangeStocks[1])/(vrangeStocks[2]-vrangeStocks[1])          # Set height of stock level bar
          if(is.function(stockLevelScaling)){
            v <- sapply(v, stockLevelScaling)
          }
          v <- min(v*stockMaxLevel, 0.85)*(y[2]-y[1])                           # Leave space for labels
          grid.rect(x = x[1], y = y[2],
                    width = x[2]-x[1], height = -v,                             # Stock data bar
                    vjust = 0, hjust = 0,
                    gp=gpar(col=NA, alpha=colStockTransp,fill=col)
          )
          grid.rect(x = x[1], y = y[1],
                    width = x[2]-x[1], height = y[2]-y[1]-v,                    # Stock data bar
                    vjust = 0, hjust = 0,
                    gp=gpar(col=NA, alpha=colStockTransp, fill="white")
          )
          grid.rect(x = x[1], y = y[1],
                    width = x[2]-x[1], height = y[2]-y[1],                      # Stock background
                    vjust = 0, hjust = 0,
                    gp=gpar(col="gray70", fill=NA, lwd=1)
          )
          if(showStockLabels=="auto"){
            a <- layout[[snn[1]]]$name
            if(is.null(a)) a <- "Stock"
            grid.text(label = a,                                                # Stock name label (upper left)
                      x=x[1]+0.008, y=y[1]-0.023,
                      hjust = 0, vjust = 0, rot = 0,
                      gp = gpar(col="black", fill=NA, cex=1.3, font=2)
            )
            a <- layout[[snn[1]]]$value
            if(is.null(a)) a <- NA
            grid.text(label = sprintf(stockValueLabelFormat,a),                 # Stock value label (upper right)
                      x=x[2]-0.007, y=y[1]-0.023,
                      just = "right", vjust = 0, rot = 0,
                      gp = gpar(col="grey50", fill=NA, cex=1.2, font=1)
            )
            grid.text(label = snn[1],                                           # Stock ID label (lower left)
                      x = x[1], y = y[2],
                      hjust = -0.2, vjust = -0.5, rot = 0,
                      gp = gpar(col=colID, fill=NA)
            ) 
          }  
        }  
      }else{  
        if(sn[n]=="FRAME"){                                                     # Display frame
          if(showFrames){
            grid.rect(x = x[1], y = y[1],
                      width = x[2]-x[1], height = y[2]-y[1],
                      vjust = 0, hjust = 0,
                      gp=gpar(col="grey80", fill=NA, lwd=1)
            )
          }  
        } else {                                                                # Any other rectangle
          col <- paste0("#",l[[n]]$col)
          if(is.null(col)) col <- "gray50"
          fill <- paste0("#",l[[n]]$fill)
          if(is.null(fill)) fill <- NA
          grid.rect(x = x[1], y = y[1],
                    width = x[2]-x[1], height = y[2]-y[1],
                    vjust = 0, hjust = 0,
                    gp=gpar(col=col, fill=fill, lwd=1)
          )
        }
      }
    }
    else if(l[[n]]$type =="oval"){
      if(sc[n]=="node"){
        if(debug){
          print(sprintf("%1s: %1s", sn[n], sc[n]))
        }
        col <- "grey70"
        grid.circle(x = (x[2]+x[1])/2, y = (y[2]+y[1])/2, r=nodeDiam/2,
                  gp=gpar(col=NA, fill=colNode)
        )
      } else{
        # plot oval grob here
      }  
    }
    else if (l[[n]]$type %in% c("line", "freeform")){
      if(l[[n]]$type=="line") nn <- 2 else nn <- l[[n]]$nodes
      xx  <- x
      yy  <- y
      le   <- rep(0,nn-1)
      i <- 1:(nn-1)
      le[i]  <- sqrt((x[i]-x[i+1])^2 + (y[i]-y[i+1])^2)
  
      if(sc[n]=="flow"){
        if(snn[2] == "SYMBOL"){
          v <- layout[[snn[1]]]$value                                           # Flow arrow width
          if(is.numeric(v)){
            col <- colFlow
          }else{
            v <- defaultFlowValue
            col <- rgb(1.0,0.0,0.0)
          }
          if(!showArrowWidth) v <- defaultFlowValue              
          v <- (v-vrangeFlows[1])/(vrangeFlows[2]-vrangeFlows[1])               # Set flow arrow width
          if(is.function(flowArrowScaling)){
            v <- sapply(v,flowArrowScaling)
          }
          v <- min(flowArrowMax*1.5, max(1,v*flowArrowMax))
        }else{
          col <- paste0("#",l[[n]]$col)
          if(is.null(col)) col <- "gray50"
          v <- l[[n]]$lwd
        }  
        if(l[[n]]$begin!=1){
          xx[1] <- x[1]+(x[2]-x[1])/le[1]*arrowLength*(1+arrowGap)
          yy[1] <- y[1]+(y[2]-y[1])/le[1]*arrowLength*aspr*(1+arrowGap)
        }    
        if(l[[n]]$end!=1){
          i <- max(1,nn-1)
          xx[i+1] <- x[i+1]+(x[i]-x[i+1])/le[i]*arrowLength*(1+arrowGap)
          yy[i+1] <- y[i+1]+(y[i]-y[i+1])/le[i]*arrowLength*aspr*(1+arrowGap)
        }
        grid.lines(x = xx, y = yy,
                   arrow = NULL,
                   gp=gpar(col=col, fill="grey80", lwd=v,
                          lineend="butt",
                          linejoin="round")
        )
        ar <- NULL
        aa <- max(minArrowAngle, 180/pi*atan(v/flowArrowMax))
        al <- arrowLength / cos(pi/180*aa)*aspr
        if(l[[n]]$begin!=1){
          ar <- arrow(angle = aa, 
                      length = unit(al, "npc"),
                      ends = "first", type="closed")
          j <- (x[2]-x[1])/le[1]*arrowLength
          xx <- c(x[1], x[1] + j) + j*arrowGap
          j <- +(y[2]-y[1])/le[1]*arrowLength*aspr
          yy <- c(y[1], y[1] +j) + j*arrowGap
          grid.lines(x = xx, y = yy,
                   arrow = ar,
                   gp=gpar(col=col, fill=col, lwd=1,
                          lineend="butt", linejoin="round")
          )
        }
        if(l[[n]]$end!=1){
          ar <- arrow(angle = aa,
                      length = unit(al, "npc"),
                      ends = "last", type="closed")
          j <- (x[nn-1]-x[nn])/le[nn-1]*arrowLength
          xx <- c(x[nn]+j, x[nn]) + j*arrowGap
          j <- +(y[nn-1]-y[nn])/le[nn-1]*arrowLength*aspr
          yy <- c(y[nn] + j, y[nn])+ j*arrowGap
          grid.lines(x = xx, y = yy,
                     arrow = ar,
                     gp=gpar(col=col, fill=col, lwd=1,
                          lineend="butt", linejoin="round")
          )
        }
      }else{
        i <- (1 * (l[[n]]$begin !=1)) + (2 * (l[[n]]$end !=1))
        ar <- arrow(angle = 20, 
                    length=unit(0.02, "npc"),
                    ends=c("first", "last","both")[i], 
                    type="closed")
        grid.lines(x = xx, y = yy,
                   arrow = ar,
                   gp=gpar(col="grey80", fill="grey80", lwd=2,
                          lineend="butt",
                          linejoin="round")
        )
      }      
    }else{
      if(debug) print(sprintf("%1s: %1s",sn[n],l[[n]]$type), quote=F)
    }
  }

  if(showLabels){                                                               # Layer 2: Labels
    for (n in sz){ 
      snn <- strsplit(sn[n],"\\s+")[[1]]
      if(l[[n]]$type=="textbox" &&
         !(snn[2] == "ID") &&                                                   # Don't show IDs 
         !(!showEquations && snn[2] == "EQUATION") &&
         !(sc[n]=="stock" && showStockLabels=="auto" && (snn[2] %in% c("NAME", "VALUE"))) &&
         !(sc[n]=="flow"  && showFlowValues %in% c(FALSE,"auto") && snn[2] =="VALUE") &&
         !(sc[n]=="flow"  && showFlowNames %in% c(FALSE,"auto")  && snn[2] =="NAME")
         ){
            x   <- l[[n]]$x
            y   <- l[[n]]$y
            txt <- l[[n]]$text
            v <- layout[[ strsplit(sn[n]," ")[[1]][1]]]$value
            if(isValidNumber(v)){                                               # Format flow value label
              v <- sprintf(flowValueLabelFormat,v)
              bg <- NULL
            }else{
              v <- paste0("t:", txt)
              bg <- rgb(1,0.5,0.5)
            } 

            col <- paste0("#",l[[n]]$col)
            if(!is.null(labelSize)) s <- labelSize else s <- l[[n]]$fontsize/5
            if(sc[n]=="flow"){                                                  
              if(labelBackground == "plain"){
                grid.rect((x[1]+x[2])/2, (y[1]+y[2])/2,                         # Flow label background
                          unit(1,"strwidth",v)*2,
                          unit(2,"strheight","M"),
                          hjust = 0.5, vjust=0.5,
                          gp=gpar(col=NA, 
                                  fill=ifelse(is.null(bg), "white", bg))
                )
              }
              else if(labelBackground == "cartouche"){                          # Flow value cartouche
                grid.roundrect((x[1]+x[2])/2, (y[1]+y[2])/2,
                          r=unit(0.3, "strheight","M"),
                          unit(1,"strwidth",v)*2,
                          unit(2,"strheight","M"),
                          gp=gpar(col=colFlow, 
                                  fill=ifelse(is.null(bg),"gray95",bg))
                )
              }
            }
            grid.text(                                                          # Flow value label 
              label = v,
              x = (x[1]+x[2])/2, y= (y[1]+y[2])/2,
              hjust = 0.5, vjust = 0.5,
              rot = 0,
              gp = gpar(col=col, fill=NA, cex=s)
            )
      }
    }
  }
  
  if(showFlowValues == "auto" || showFlowNames == "auto" ){
      for (n in sz){
        if(sc[n] == "flow" &&  l[[n]]$type %in% c("line", "freeform") &&
            grepl(" SYMBOL", sn[n])){
          x <- l[[n]]$x
          y <- l[[n]]$y     
          nn <- l[[n]]$nodes
          if(is.null(nn)) nn <-2
          i <- floor(nn/2)                                                      # Position and orientation of
          if(abs(x[i+1]-x[i])>abs(y[i+1]-y[i])){                                # Flow labels if set to auto
            r <- atan((y[i+1]-y[i])/(x[i+1]-x[i])/aspr)
          } else{
            r <- atan((x[i+1]-x[i])/(y[i+1]-y[i])/aspr)-pi/2
          }
          if(is.nan(r)) r<-0
          xx <- (x[i+1]+x[i])/2
          yy <- (y[i+1]+y[i])/2

          if(showFlowValues=="auto"){
            v <- layout[[strsplit(sn[n]," ")[[1]][1]]]$value
            grid.text(label = sprintf("%1.0f",v),
                            x = xx, y= yy,
                            hjust = 0.5, vjust = 0.5, rot = 180/pi*r,
                            gp = gpar(col="black", fill=NA, cex=1.5)
            )
          }
          if(showFlowNames=="auto"){
            d <- 0.02
            j <- strsplit(sn[n]," ")[[1]][1]
            v <- layout[[j]]$name
            if(is.null(v) || is.na(v)) v <- j
            grid.text(label = v,
                            x = xx-d*sin(r)/aspr , y= yy+d*cos(r),
                            hjust = 0.5, vjust = 0.5, rot = 180/pi*r,
                            gp = gpar(col="gray50", fill=NA, cex=1)
                  )
          }
        }  
      }
  }

  if(showIDs){                                                                  # Layer 3: Shape IDs

    for (n in 1:length(l)){ 
      x <- l[[n]]$x
      y <- l[[n]]$y
      xx <- NULL
      yy <- NULL
      
      if (l[[n]]$type %in% c("line", "freeform")){
         if(sc[n]=="flow" && l[[n]]$begin!=1){
          if(l[[n]]$type=="line") nn <- 2 else nn <- l[[n]]$nodes
          le   <- rep(0,nn-1)
          i <- 1:length(le)
          le[i]  <- sqrt((x[i]-x[i+1])^2 + (y[i]-y[i+1])^2)
          xx <- x[1] + (x[2]-x[1])/le[1]*arrowLength
          yy <- y[1] + (y[2]-y[1])/le[1]*arrowLength*aspr
        }else{
          xx <- x[1]
          yy <- y[1]
        }  
      }else
      if(l[[n]]$type =="rectangle"){
          xx <- x[1]
          yy <- y[2]
      } else
      if(l[[n]]$type =="oval"){
        xx <- (x[2]+x[1])/2
        yy <- (y[2]+y[1])/2
      }else{
        xx <- x[1]
        yy <- y[2]
      }
      if(!is.null(xx) && !is.null(yy)){
        if(sc[n]!="flow"){
          grid.circle(x = xx, y= yy,
                      r=0.005, 
                      gp=gpar(col=NA, fill=colID),
          )  
        }  
        grid.text(label = sn[n],
                  x = xx, y = yy,
                  hjust = -0.2, vjust = -0.5, rot = 0,
                  gp = gpar(col=colID, fill=NA)
        ) 
      }  
    }
  }  

  # Header and footer
  
  upViewport()
  
  if(is.null(header)) header <- "Market Architecture Map"
  if(header!=""){
    grid.text(
      label = header,
      x = mar[2], y= 1-mar[3]+0.01,
      hjust = 0, vjust = 0,
      gp = gpar(col="black", fill=NA, cex=1.4, font=2)
    )
  }  

  
  if(is.null(footer)) footer <- "Footnote"
  if(footer =="<size>"){
    footer <- sprintf("Device dimension: %1.3f x %1.3f inch", 
                    par()$pin[1], par()$pin[2])
  }  
  if(footer!=""){
    grid.text(
      label = footer,
      x = mar[2], y= 0.005,
      hjust = 0, vjust = 0,
      gp = gpar(col="grey60", fill=NA, cex=0.8),
    )
  }  
}

if(!exists("layout")){
  Print("Layout not found. Trying to load.")
  layout <- loadLayout(settings$pathMap)
}


# Runtime ~ 210 ms

renderArchitectureMap(layout=layout, footer = "<size>")

```

```{r Visualisation - Map individual patient history}

mapPatientHistoryIndividual <-function(p                   = NULL,              # Vector of pointers to patients
                                       id                  = NULL,              # vector of patient IDs
                                       showStocks          = TRUE,
                                       showinclasschange   = TRUE,
                                       showRx              = TRUE,                                       
                                       header              = NULL, 
                                       footer              = NULL,
                                       vlines              = NULL,
                                       generatePDFs        = FALSE,
                                       pdfname             = ""
                                       )
{

  sampleSize          <- 50                                                     # Number of patients (only Pdf output)
  showStocks          <- TRUE
  showRx              <- TRUE
  rxDataFormat        <- c("table","bitvectors")[2]
  fontSize            <- 0.65
  mai                 <- c(1,1,1,1)*0.03                                        # Margins to inner VP (0..1)
  imagePos            <- c(0.25, 0.95, 0.1, 0.89)
  labelPos            <- c(0.00,0.11)
  linesv              <- 50                                                     # Vertical lines (aspect ratio)
  showFrames          <- FALSE                                                  # Show frame around viewports (debug)
  defaultCol          <- rgb(0.5,0.5,1.0)
  inClassChangeCol    <- rgb(0.9,0.9,0.0)
  legendPos           <- "bottom"
  
  plt <- function(d, yp=0, lab1="", lab2="",lab3="", col=c("white", "blue")){
    
    n <- nrow(d)
    h <- yi*n
    grid.raster(image=matrix(col[d+1], ncol = ncol(d)),
                x=mean(imagePos[1:2]), y=+yp-h/2, 
                width = w, height=h,
                interpolate = F)
  
    x <- (0:60)/60 * w + imagePos[1]
    y <- yp
    grid.segments(x0=x, x1=x, y0=y, y1=y-h,
                  gp=gpar(col=ifelse(0:60%%12==0,"gray70", "gray90")))

    x <- imagePos[1]
    y <- yp - (0:nrow(d))/nrow(d)*h
    grid.segments(x0=x, x1=x+w, y0=y, y1=y,
                  gp=gpar(col=ifelse(1:n==1,"gray90", "gray90")))
    grid.text(label = lab2,
              x=labelPos[1], y=y[1]-yi/2,
              hjust=0, vjust = 0,
              gp=gpar(cex=0.6, col="gray50", font=2))
    grid.text(label = lab1,
              x=labelPos[2], y=y[-1]+yi/2,
              hjust=0, vjust = 0,
              gp=gpar(cex=0.6, col="gray50"))
  }
  
  if(sampleSize>100){
    warning(sprintf("Sample size too large (%1d). Limiting to 100",
                    sampleSize))
    sampleSize <- 100
  } 
  if(!generatePDFs) sampleSize <- 1L
  if (is.null(p) && is.null(id)){
    p <- sample.int(length(e$pt$patient), sampleSize)
  }  
  if (is.null(p) && !is.null(id)){
    p <- match(id,e$pt$patient)
  }
  if (!is.null(p) & is.null(id)){
    id <- e$pt$patient[p]
  }  
  
  w <- diff(imagePos[1:2])
  h <- diff(imagePos[3:4])
  yi <- h/linesv
  
  pg <- 1
  for(pg in 1:length(p)){
    
    yp <- imagePos[4] - 1*yi

    if (generatePDFs) dbprint(sprintf("Rendering page %1d",pg))

    grid.newpage()                                                                # Outer frame, leave margin
    vp <-  viewport(x= unit(0.5, "npc"),
                    y= unit(0.5, "npc"), 
                    width = unit(1, "npc"), 
                    height = unit(1, "npc"), 
                    gp = gpar(cex=1.0),
                    name = "baseVP")
    pushViewport(vp)
    
    if(showFrames){  
      grid.rect(0, 0, 1, 1, vjust = 0, hjust = 0,                               # Frame around outer VP
                gp=gpar(col="grey80", fill=NA))
    }  
    i <- min((1-mai[2]-mai[4]), (1-mai[1]-mai[3]))                              # Inner VP (apply margins)
    vpi <- viewport(x= unit(mai[2]+i/2, "npc"),
                    y= unit(mai[1]+i/2, "npc"), 
                    width  = unit(i, "npc"), 
                    height = unit(i, "npc"), 
                    gp = gpar(cex=1),
                    name = "innerVP")
    pushViewport(vpi)  
    
    if(showFrames){  
      grid.rect(0, 0, 1, 1, vjust = 0, hjust = 0,                               # Frame around outer VP
                gp=gpar(col="grey95", fill=NA))
    }
    i <- as.integer(substr(e$info$dataLastMonth,1,2))
    j <- as.integer(substr(e$info$dataLastMonth,4,7))-60/12+1
    x <- (seq(12-i,59,12)+6)/60*w+imagePos[1]
    grid.text(label = j:(j+4),
              x=x, y=imagePos[4]+h/20,
              vjust = 0, hjust = 0.5, rot=0,
              gp=gpar(cex=0.9, col="gray50")
             )
    x <- (0:60)/60 * w + imagePos[1]
    y <- imagePos[3]
    grid.text(label = 1:60,
              x=x[-1]-w/60/2, y=imagePos[4]+h/60,
              vjust = 0.5, hjust = 0, rot=90,
              gp=gpar(cex=0.5, col="gray50")
             )

    # Rx timeline - Stocks -----------------------------------------------------

    if(showStocks){
      
      err <- NULL 
      if(!exists("s", envir = e, inherits = FALSE)){
        err <-"Stock table not found"
      }
      if(!all(id %in% e$pt$patient)){
        err <- "Patient IDs not found"
      } 
      sid <- e$en$stocks$id                                                     # Stock IDs, assumes correct number and order
      d <- matrix(0L, nrow=length(sid), ncol=60)
      i <- as.integer(e$s[p[pg],sprintf("M%02d",1:60), with=FALSE])             # Get stock values
      if(length(i)!=60){
        err <- "Stock data incomplete"
      } 
      if(is.null(err)){
        d[cbind(nrow(d)-abs(i),1:60)] <- i
        l <- with(e$en$stocks, ifelse(nchar(display_name)<20,                   # Long or short name, depedning on fit
                                    display_name, short_name))
        row.names(d) <- rev(l)
        k <- e$en$stocks$plot_colour
        k[is.na(strtoi(gsub("#", "0x",k)))] <- defaultCol
        stockCols <- c("#FFFFFF", rep(defaultCol, max(e$en$stocks$id_numeric)))
        stockCols[e$en$stocks$id_numeric+1] <- k
        plt(abs(d),
            yp=yp,col=stockCols,
            lab1=row.names(d),
            lab2="Stock",
            lab3=""
        )
        if(showinclasschange){                                                      # Drug changes in the same class
          dc <-  matrix(0L, ncol=60, nrow=nrow(d))
          for (i in 2:60){
            dc[,i] <- (abs(d[,i-1])==abs(d[,i])) & (d[,i]>0)                        # Find months with therapy change
          }
          for (i in which(rowSums(dc)>0)){
            x <- (which(dc[i,]>0)-0.5)*w/60 + imagePos[1]
            y <- imagePos[4] - (i+1)*yi
            grid.segments(x0=x, x1=x, y0=y+yi*0.25, y1=y+yi*0.75, 
                     gp=gpar(lwd=4, lend=1,
                     col=inClassChangeCol)
            )
          }  
        }
      }else{
        warning(err)
      }
    }
    yp <- yp-(nrow(d)+1.5) * yi
      
       
    # Rx timeline - Molecule ---------------------------------------------------
  
    if(showRx){
      err <- NULL 
      if(!all(id %in% e$pt$patient)){
        err <- "Patient IDs not found"
      } 
      if(rxDataFormat == "table"){                                              # XXX Needs to be updated to whatever alternative
        if(exists("rx_table", envir = e, inherits = FALSE)){                    # Format we want to use!
          a <- e$rx_table[patient==id[pg],]
          a <- strsplit(a[order(p1),d1],",")
          a[a=="-"] <-0
          drugIds <- as.numeric(sort(unique(unlist(a))))
          d <- matrix(0L, nrow=length(drugIds), ncol=60)
          row.names(d) <- e$en$generic_name[match(drugIds, e$en$drg_id)]
          for (j in 1:length(drugIds)){
            d[j,] <- 1L*sapply(a,function(x) drugIds[j] %in% x)
          }
        }else{
          err <-"Rx table format data not found"
        }
      } else 
      if(rxDataFormat == "bitvectors"){
        drugIds <- e$en$drugs$drug_id
        d <- matrix(0L, ncol=60, nrow = length(drugIds))
        for (i in 1:length(drugIds)){                                           # Have to check all drug vectors...
          n <- paste0("rx_",e$en$drugs$rname[i])
          if(exists(n, envir = e$rx, inherits = FALSE)){
            d[i,] <- int64ToBitArray(get(n,envir = e$rx)[p[pg]], drop=TRUE)
          }
        }
        i <- rowSums(d)>0
        d <- d[i,,drop=FALSE]
        d <- data.table(id       = drugIds[i], 
                        name     = e$en$drugs$generic_name[i],
                        class_id = e$en$drugs$drug_class_id[i],
                        class    = e$en$drugs$drug_class[i], 
                        col      = e$en$drugs$plot_colour[i],
                        d)
        setnames(d,6:65,sprintf("M%02d",1:60))
        d <- d[order(class_id,id),]
      }

      if(is.null(err)){
        yp <- yp + yi/2
        grid.segments(x0=imagePos[1], y0=yp, x=imagePos[2], y1=yp, 
                      gp=gpar(col="grey80", lwd=1, xpd=T))
        yp <- yp - yi
        k <- e$en$drugs$plot_colour
        k[is.na(strtoi(gsub("#", "0x",k)))] <- defaultCol
        drugCols <- c("#FFFFFF", rep(defaultCol, max(e$en$drugs$drug_id)))
        for(i in unique(d$class_id)){
          j <- which(d$class_id==i)
          plt(as.matrix(d[j,M01:M60]) * d$class_id[j],yp=yp, 
              lab1 = d$name[j],lab2=d$class[j], lab3="", 
              col = drugCols
          )
          yp <- yp - yi*(length(j) + 0.75)                                          # spacing between mol classes
        }
      }
      
      if(!is.null(vlines)) {
        x <- imagePos[1]+(range(vlines)-0.5)*w/60
        y <- c(imagePos[4], yp)+c(1,-1)*yi
        if (length(vlines)>1){
          x <- x+c(-1,1)*w/60/2
          y <- y+c(-1,1)*yi
          grid.segments(x0=x[1],
                        x1=x[2],
                        y0=y, y1=y,
                        gp=gpar(col="red", lwd=2))
        }
        grid.segments(x0=x, x1=x,
                      y0=y[1], y1=y[2],
                      gp=gpar(col="red", lwd=2))
      }
    }  
  }

  # Legend ---------------------------------------------------------------------

  if(legendPos=="bottom") yp <- 0.08
  l <- (1:length(stockCols[-1])-1)
  x <- (l %% 5)/5 *w + imagePos[1]
  y <- yp-yi*(2*(l-l%%5)/5+2)
  grid.rect(x, y, w/60, yi, hjust = 0,
            gp=gpar(fill = stockCols[-1], col=NA))
  grid.text(label = e$en$stocks$short_name[-1],
            x=x+w/30,y=y,hjust = 0,vjust = 0.5,
            gp=gpar(col="gray50", cex=0.7))

  # Header and footer ----------------------------------------------------------

  if(is.null(header)) header <- id  
  grid.text(label = header,
            x=labelPos[1], y=1.00, hjust = 0, vjust = 1,
            gp=gpar(col="black", cex=1.15, font=2)
  )
  if(!is.null(e$pt$gender[p[pg]]) && !is.null(e$pt$age[p[pg]])){
    grid.text(paste0(e$pt$gender[p[pg]], e$pt$age[p[pg]]),
              x=labelPos[1], y=0.955, hjust=0,
              gp=gpar(col="gray50", cex=0.9)
             )
  }
  if(!is.null(footer)){
    grid.text(label = footer,
              x=labelPos[1], y=0.01, hjust = 0, vjust = 0,
              gp=gpar(col="gray50", cex=0.7, font=1))
  }  
}

# Examples ---------------------------------------------------------------------

if(settings$runExamples){
    
  mapPatientHistoryIndividual(p=NULL,                                           # Random patient
                              footer = "Random patient", 
                              vlines = c(20,30)
                              )

  
  if(FALSE){                                                                    # 100 patients you are at some point on stock sid

    sampleSize <- 10
    pdf("Patient examples (individual).pdf", width = 8.58, height=6.75)

    for(sid in setdiff(e$en$stocks$id, c("S00","S01"))){
     
      i <- e$en$stocks[match(sid,id),id_numeric]
      p <- which(rowSums(abs(e$s[,M01:M60])==i)>0)
      if(length(p)>=sampleSize){
        l <- sprintf("%1s: %1d patients",sid, length(p))
        for(i in 1:20){
          cat(".")
          k <- sample(p,1)
          m <- match(1,abs(e$s[k,M01:M60])==7)
          
          mapPatientHistoryIndividual(p=k, 
                                      header = paste0(sid,": ", e$pt$patient[k]),
                                      footer = l, 
                                      vlines = c(m,m)
                                      )
        }
      }else{
        cat("\n")
        dbprint(sprintf("Insufficient samples for %1s (n=%1d)", sid, length(p)))      
      }
    }  
    dev.off()
  }  
  
}

```

```{r Visualisation - Map multiple patient histories}

mapPatientHistoryMultiple <-function(p                   = NULL,                # Vector of pointers to patients
                                     id                  = NULL,                # vector of patient IDs
                                     type                = "stock",             # Only "stock" implemented
                                     header              = NULL, 
                                     footer              = NULL,
                                     showinclasschange   = TRUE,                # Mark change in drugs in class
                                     vlines              = NULL)
{
  sampleSize        <- 50
  fontSize          <- 0.65
  mai               <- c(1,1,1,1)*0.03                                          # Margins to inner VP (0..1)
  imagePos          <- c(0.15, 0.95, 0.10, 0.89)
  labelPos          <- c(0.0,0.15)
  showFrames        <- FALSE
  inClassChangeCol  <- rgb(0.95,0.95,0.0)
  defaultCol        <- rgb(1.0,1.0,0.0)

  if (is.null(p) && is.null(id)){
    p <- sample.int(nrow(e$pt), sampleSize)              
  }
  if (is.null(p) && !is.null(id)){
    p <- match(id,e$pt$patient)
  }
  if (!is.null(p) && is.null(id)){
    id <- e$pt$patient[p]
  }
  
  if(type=="stock"){
    d <- as.matrix(e$s[id,sprintf("M%02d",1:60), on="patient", with=FALSE])
    row.names(d) <- as.character(e$pt$patient[p])
    k <- e$en$stocks$plot_colour
    k[is.na(strtoi(gsub("#", "0x",k)))] <- defaultCol
    col <- c("#FFFFFF",rep(defaultCol,max(e$en$stocks$id_numeric)))             # Colour lookup table. No stock 'white'
    col[e$en$stocks$id_numeric+1L] <- k 
  }

  n <- nrow(d)
  w <- diff(imagePos[1:2])
  h <- diff(imagePos[3:4])

  grid.newpage()                                                                # Outer frame, leave margin
  vp <-  viewport(x= unit(0.5, "npc"),
                  y= unit(0.5, "npc"), 
                  width = unit(1, "npc"), 
                  height = unit(1, "npc"), 
                  gp = gpar(cex=1.0),
                  name = "baseVP")
  pushViewport(vp)
  
  grid.rect(0, 0, 1, 1, vjust = 0, hjust = 0,                                   # Frame around outer VP
            gp=gpar(col="grey80", fill=NA))

  i <- min((1-mai[2]-mai[4]), (1-mai[1]-mai[3]))                                # Inner VP (apply margins)
  vpi <- viewport(x= unit(mai[2]+i/2, "npc"),
                  y= unit(mai[1]+i/2, "npc"), 
                  width  = unit(i, "npc"), 
                  height = unit(i, "npc"), 
                  gp = gpar(cex=1),
                  name = "innerVP")
  pushViewport(vpi)  
    
  if(showFrames){
    grid.rect(0, 0, 1, 1, vjust = 0, hjust = 0,                                 # Frame around inner VP
               gp=gpar(col="grey95", fill=NA))
  }
  grid.raster(image=matrix(col[abs(d)+1], ncol = ncol(d)),
              x=mean(imagePos[1:2]), y=mean(imagePos[3:4]), 
              width = w, height=h,
              interpolate = FALSE
              )
  
  x <- (0:60)/60 * w + imagePos[1]
  y <- imagePos[3]
  grid.segments(x0=x, x1=x, y0=y, y1=y+h, 
                gp=gpar(col=ifelse(0:60%%12==0,"gray50", "gray90")))
  
  grid.text(label = 1:60,
            x=x[-1]-w/60/2, y=imagePos[4]+h/60,
            vjust = 0.5, hjust = 0, rot=90,
            gp=gpar(cex=0.6, col="gray50")
            )

  i <- as.integer(substr(e$info$dataLastMonth,1,2))
  j <- as.integer(substr(e$info$dataLastMonth,4,7))-60/12+1
  x <- (seq(12-i,59,12)+6)/60*w+imagePos[1]
  grid.text(label = j:(j+4),
            x=x, y=imagePos[4]+h/18,
            vjust = 0, hjust = 0.5, rot=0,
            gp=gpar(cex=0.8, col="gray50"))
  x <- imagePos[1]
  y <- (0:n)/n * h + imagePos[3]
  grid.segments(x0=x, x1=x+w, y0=y, y1=y, 
                gp=gpar(col=ifelse(0:60%%12==0,"gray90", "gray90"))
                )
  grid.text(label = id,
            x=labelPos[1], y=rev(y[-1]),
            hjust = 0, vjust = 1, 
            gp=gpar(cex=0.6, col="gray50")
            )
  grid.text(label = "Patient ID",
            x=labelPos[1], y=imagePos[4]+h/60,
            hjust=0, vjust = 0,
            gp=gpar(cex=0.6, col="gray50")
            )
  if(showinclasschange){                                                        # Drug changes in the same class
    dc <-  matrix(0L, ncol=60, nrow=sampleSize)
    for (i in 2:60){
      dc[,i] <- (abs(d[,i-1])==abs(d[,i])) & (d[,i]>0)                          # Find months with therapy change
    }
    for (i in which(rowSums(dc)>0)){
      x <- (which(dc[i,]>0)-0.5)*w/60 + imagePos[1]
      y <- imagePos[4] - i*h/n
      grid.segments(x0=x, x1=x, y0=y+h/n*0.25, y1=y+h/n*0.75, 
               gp=gpar(lwd=4, lend=1,
               col=inClassChangeCol)
      )
    }
  }

  # Legend ---------------------------------------------------------------------

  sid <- with(e$en$stocks, paste(id,"-", short_name))
  l <- (1:length(sid[-1])-1)
  x <- (l %% 5)/5 *w + imagePos[1]
  y <- -(l-l%%5)/n/3 *h + imagePos[3]-h/n*2.0
  grid.rect(x, y, w/60, h/n, hjust = 0,
            gp=gpar(fill = col[-1], col=NA)
            )
  grid.text(label = sid[-1],
            x=x+w/30,y=y,hjust = 0,vjust = 0.5,
            gp=gpar(col="gray50", cex=0.7)
            )

  # Header and footer ----------------------------------------------------------
  
  if(is.null(header)) header <- sprintf("Random sample (n=%1d)", sampleSize)
  grid.text(label = header,
            x=labelPos[1], y=1.0, hjust = 0, vjust = 1,
            gp=gpar(col="black", cex=1.15, font=2))
  if(!is.null(footer)){
    grid.text(label = footer,
              x=labelPos[1], y=0.0, hjust = 0, vjust = 0,
              gp=gpar(col="gray50", cex=0.7, font=1))
  }  
  
  if(!is.null(vlines)) {
    x <- imagePos[1]+(range(vlines)-0.5)*w/60
    y <- imagePos[3:4]+c(-1,1)*h/n/2
    if (length(vlines)>1){
      x <- x+c(-1,1)*w/60/2
      y <- imagePos[3:4]+c(-1,1)*h/n/2
      grid.segments(x0=x[1], 
                    x1=x[2],
                    y0=y, y1=y,
                    gp=gpar(col="red", lwd=2))
    }
    grid.segments(x0=x, x1=x,
                  y0=y[1], y1=y[2],
                  gp=gpar(col="red", lwd=2))
  }
  return(id)
}


# Examples ---------------------------------------------------------------------

if(settings$runExamples){
  id <- mapPatientHistoryMultiple(p=NULL)
  # n <- 3
  # mapPatientHistoryIndividual(id=id[n])
  # e$rx_table[patient == id[n],.(p1,d1)]
  #mapPatientHistoryMultiple(p=NULL, footer = "Footer", vlines = c(10,22))


  mapPatientHistoryMultiple(id=id)
  p=match(id, e$pt$patient)
  mapPatientHistoryMultiple(p=p)
p
    
  
  
  if(FALSE){                                                                    # 100 patients you are at some point on stock sid

    sampleSize <- 50
    pdf("Patient examples (multiple).pdf", width = 8.58, height=6.75)

    for(sid in setdiff(e$en$stocks$id, c("S00","S01"))){
     
      i <- e$en$stocks[match(sid,id),id_numeric]
      p <- which(rowSums(abs(e$s[,M01:M60])==i)>0)
      if(length(p)>0){
        if(length(p)<sampleSize){
          j <- c(p, rep(NA,sampleSize-length(p)))
        } else{
          j <- sample(p, sampleSize)
        }
        l <- sprintf("%1s: %1d patients",sid, length(p))
        mapPatientHistoryMultiple(p=j, 
                                  header = paste0(sid,": ", e$pt$patient[k]),
                                  footer = l, 
                                  vlines = c(m,m)
                                  )
      }else{
        cat("\n")
        dbprint(sprintf("Insufficient samples for %1s (n=%1d)", sid, length(p)))      
      }
    }  
    dev.off()
  }  
  
}



```

```{r Visualisation - Map bit vector}

mapBitVector <-function(v                   = NULL,                             # Vector of pointers to patients
                        id                  = NULL,
                        header              = NULL,
                        footer              = NULL,
                        vlines              = NULL,
                        markers             = NULL
                       )
{
  
  sampleSize        <- 50
  fontSize          <- 0.65
  mai               <- c(1,1,1,1)*0.03                                          # Margins to inner VP (0..1)
  imagePos          <- c(0.15, 0.95, 0.10, 0.89)
  labelPos          <- c(0.0,0.15)
  mapColours        <- c("white", rgb(0.4,0.4,1.0))
  markerCol         <- "orange"
  showFrames        <- FALSE

  if(!is.null(id) && length(id)!=length(v)){
    warning("Patient ID vector not same length as input. Ignoring")
    id <- NULL
  }
  if(is.null(id)) id <- 1:length(v)
  if (length(v)> sampleSize){
    warning(sprintf("Input vector too long (n=1%d). Sampling %1d elements",
                    length(v), sampleSize))
    i <- sample.int(length(v), sampleSize)
    v <- v[i]
    if(!is.null(id)) id <- id[i]
    if(!is.null(markers)) markers <- markers[i]
  }

  d <- int64ToBitArray(v,bits=60)
  colnames(d) <- sprintf("M%02d", 1:60)
  if(!is.null(id)){
    rownames(d) <- as.character(id)
  }  

  n <- nrow(d)
  w <- diff(imagePos[1:2])
  h <- diff(imagePos[3:4])

  grid.newpage()                                                                # Outer frame, leave margin
  vp <-  viewport(x= unit(0.5, "npc"),
                  y= unit(0.5, "npc"), 
                  width = unit(1, "npc"), 
                  height = unit(1, "npc"), 
                  gp = gpar(cex=1.0),
                  name = "baseVP")
  pushViewport(vp)
  
  grid.rect(0, 0, 1, 1, vjust = 0, hjust = 0,                                   # Frame around outer VP
            gp=gpar(col="grey80", fill=NA))

  i <- min((1-mai[2]-mai[4]), (1-mai[1]-mai[3]))                                # Inner VP (apply margins)
  vpi <- viewport(x= unit(mai[2]+i/2, "npc"),
                  y= unit(mai[1]+i/2, "npc"), 
                  width  = unit(i, "npc"), 
                  height = unit(i, "npc"), 
                  gp = gpar(cex=1),
                  name = "innerVP")
  pushViewport(vpi)  
    
  if(showFrames){
    grid.rect(0, 0, 1, 1, vjust = 0, hjust = 0,                                 # Frame around inner VP
               gp=gpar(col="grey95", fill=NA))
  }
  grid.raster(image=matrix(mapColours[abs(d)+1], ncol = ncol(d)),
              x=mean(imagePos[1:2]), y=mean(imagePos[3:4]), 
              width = w, height=h,
              interpolate = FALSE
              )
  x <- (0:60)/60 * w + imagePos[1]
  y <- imagePos[3]
  grid.segments(x0=x, x1=x, y0=y, y1=y+h, 
                gp=gpar(col=ifelse(0:60%%12==0,"gray70", "gray90")))
  
  grid.text(label = 1:60,
            x=x[-1]-w/60/2, y=imagePos[4]+h/60,
            vjust = 0.5, hjust = 0, rot=90,
            gp=gpar(cex=0.6, col="gray50")
            )
  k <- e$info$dataLastMonth
  i <- as.integer(substr(k,1,2))
  j <- as.integer(substr(k,4,7))-60/12+1
  x <- (seq(12-i,59,12)+6)/60*w+imagePos[1]
  grid.text(label = j:(j+4),
            x=x, y=imagePos[4]+h/18,
            vjust = 0, hjust = 0.5, rot=0,
            gp=gpar(cex=0.8, col="gray50"))
  x <- imagePos[1]
  y <- (0:n)/n * h + imagePos[3]
  grid.segments(x0=x, x1=x+w, y0=y, y1=y, 
                gp=gpar(col=ifelse(0:60%%12==0,"gray90", "gray90")))

  grid.text(label = id,
            x=labelPos[1], y=rev(y[-1]),
            hjust = 0, vjust = 1, 
            gp=gpar(cex=0.6, col="gray50"))

  # Header and footer ----------------------------------------------------------
  
  if(is.null(header)) header <- sprintf("Random sample (n=%1d)", sampleSize)
  grid.text(label = header,
            x=labelPos[1], y=1.0, hjust = 0, vjust = 1,
            gp=gpar(col="black", cex=1.15, font=2))
  if(!is.null(footer)){
    grid.text(label = footer,
              x=labelPos[1], y=0.0, hjust = 0, vjust = 0,
              gp=gpar(col="gray50", cex=0.7, font=1))
  }  

  if (!is.null(markers)){               
    for (i in 1:n){
      x <- (markers[i]-0.5)*w/60 + imagePos[1]
      y <- imagePos[4] - i*h/n
      grid.segments(x0=x, x1=x, y0=y+h/n*0.2, y1=y+h/n*0.8, 
               gp=gpar(lwd=4, lend=1,
               col=markerCol)
      )
    }
  }  
    
  if(!is.null(vlines)) {
    x <- imagePos[1]+(range(vlines)-0.5)*w/60
    y <- imagePos[3:4]+c(-1,1)*h/n/2
    if (length(vlines)>1){
      x <- x+c(-1,1)*w/60/2
      y <- imagePos[3:4]+c(-1,1)*h/n/2
      grid.segments(x0=x[1], 
                    x1=x[2],
                    y0=y, y1=y,
                    gp=gpar(col="red", lwd=2))
    }
    grid.segments(x0=x, x1=x,
                  y0=y[1], y1=y[2],
                  gp=gpar(col="red", lwd=2))
  }
}


# Examples ---------------------------------------------------------------------

if(settings$runExamples){
  
  # Random sample from random rx-vector

  n <- sample(ls(e$rx),1)
  v <- get(n,envir = e$rx)
  p <- sample(which(v>0),50)
  mapBitVector(v[p],                                                            # int64 input vector. If length>40 will be sampled
               id = e$pt$patient[p],                                            # Optional patients IDs or other row headers
               vlines = c(20,30),                                               # Box around selected months to highlight range
               markers = runif(50,20,30),                                       # Marker on patient timeline XXX: enable multiple
               header = paste("Sample from vector: ",n), 
               footer = "Random sample")
  rm(n,p,v)
}

```

```{r Visualisation - Plot age and gender distribution}

plotAgeAndGenderDistribution <- function(ageRange = NULL, 
                                         projected = FALSE
                                        )
{

  if(is.null(ageRange)) ageRange <- seq(min(e$pt$age), max(e$pt$age))

  i <- e$pt[,.(n=.N,pats=sum(pweight)), keyby=list(gender, age)]
  w <- e$pt[,.(n=.N,pats=sum(pweight)), keyby=list(age)]
  w$pweight <- w$pats/w$n
  
  opar = par(no.readonly = TRUE)
  par(mfrow=c(1,1), mar=c(7,5,6,3))
  
  j <- ifelse(projected,"pats","n")
  a <- as.matrix(cbind(i[gender=="M" & match(ageRange,age),..j], 
                  i[gender=="F" & match(ageRange,age), ..j]))
  t <-barplot(t(a), border="white", space=0, 
          col=c(rgb(0.5,0.5,0.8), rgb(0.8,0.5,0.5)),
          las=1, cex.axis = 0.8)
  text(x=t, y=grconvertY(-0.01, "npc"), 
       labels = ageRange, xpd=TRUE, cex=0.55, srt=90, col="gray50")
  
  x <- ageRange[ageRange%%10==0]
  text(x=x-min(ageRange)+0.5, y=grconvertY(-0.06, "npc"),
       labels = x, xpd=TRUE, cex=0.8, srt=0, col="black", adj = c(0.5,0))
  
  y <- w$pweight[match(ageRange,w$age)]
  text(x=t, y=grconvertY(0.10, "nfc"), adj=c(1,0.5),
       labels = sprintf("%1.1f",y), xpd=TRUE, cex=0.55, srt=90, col="gray50")
  text(x=grconvertX(0.02, "npc"), y=grconvertY(0.09, "nfc"), adj=c(1,0.5),
       labels = "pweight:", xpd=TRUE, cex=0.7, col="gray50")
  
  headerLine("Age and gender distribution of sample population")
  a <- ifelse(projected, "Projected patient number ('000 per cohort)", 
              "Unprojected sample count")
  footerLine(a, source = TRUE)
  
  par(opar)
  
  return(dist=i)
} 

# Examples ---------------------------------------------------------------------

if(settings$runExamples){
  plotAgeAndGenderDistribution(ageRange = NULL, projected = TRUE)
}

```

```{r Visualisation - Plot stock and flow summary table}

plotStockAndFlowSummary <- function(period                  = 49:60,
                                    projected               = FALSE,
                                    aggregateNaiveAndLapsed = TRUE,
                                    gridOutput              = TRUE,
                                    debug                   = TRUE
                                   )
{  
  # Summary - Stocks -------------------------------------------------------------

  k <- sprintf("M%02d",max(period))
  i <- e$ss[type==ifelse(projected,"pats","n"), stock_numeric]
  i <- cbind(stock_name = e$en$stocks$display_name[match(i,e$en$stocks$id_numeric)],
             stock_ID   = e$en$stocks$id[match(i,e$en$stocks$id_numeric)],
             n          = e$ss[type=="n",k,with=F], 
             pats       = e$ss[type=="pats", k, with=F])
  setnames(i,c("stock", "ID", "n", "patients"))
  
  if(aggregateNaiveAndLapsed){                                                    # Aggregate naive and lapsed
    i[ID=="S00",c("n","patients")] <- 
        as.list(colSums(i[ID %in% c("S00", "S01"),.(n,patients)]))
    i[ID=="S00","ID"] <- "S00/01"
    i[1,"ID"]    <- "S00/01"
    i[1,"stock"] <- "naive/lapsed"
    i <- i[-(ID=="S01"),]
  }
  stockSummary <- i 
  rm(i,k)
  
  # Summary - Flows --------------------------------------------------------------

  k <- c("from", "to", sprintf("M%02d",period))
  a <- e$fs[e$fs$type==ifelse(projected,"pats","n"),k, with=FALSE]
  a <- cbind(a[,1:2], flow=rowSums(a[,grep("^M",names(a)),with=FALSE]))
  
  a$from <- e$en$stocks$id[match(a$from, e$en$stock$id_numeric)]
  a$to   <- e$en$stocks$id[match(a$to,   e$en$stock$id_numeric)]
  
  i <- data.table(pivot_wider(a, names_from = "to", values_from = "flow"))
  i <- cbind(stock=e$en$stock$display_name[match(i$from, e$en$stock$id)],i)
  
  if(aggregateNaiveAndLapsed){                                                    # Aggregate naive and lapsed
    i[from=="S00",3:ncol(i)] <- 
        as.list(colSums(i[from %in% c("S00", "S01"),3:ncol(i)]))
    i[from=="S00","from"]  <- "S00/01"
    i[from=="S00/01","stock"] <- "naive/lapsed"
    i <- i[-which(from=="S01"),]
    i$S01 <- rowSums(i[,S00:S01])
    i$S00 <- NULL
  }
  flowSummary <- i
  rm(a,i,k)
  
  # Output results ---------------------------------------------------------------
  
  if(!gridOutput || debug){
    {
      l <- max(sapply(stockSummary$stock,nchar))
      dbprint(strrep("-",l+28))
      dbprint(sprintf("Stocks - M%02d", max(period)))
      dbprint(strrep("-",l+28))
      print(stockSummary, width=8)
      dbprint(strrep("-",l+28))
    }
  
    {
      l <- max(sapply(flowSummary$stock,nchar))
      dbprint(strrep("-",l+82))
      dbprint(sprintf("Flows - total for %1d months (M%02d-M%02d)", 
                    length(period), min(period), max(period)))
      dbprint(strrep("-",l+82))
      dbprint(flowSummary,width=8)
      dbprint(strrep("-",l+82))
    }
  }
  
  if(gridOutput){
    
    library(gridExtra)
    
    tt <- ttheme_default(base_size = 9, padding = unit(c(5,3),"mm"),
                         core=list(fg_params=list(hjust=1,x=0.95)),
                         colhead=list(fg_params=list(hjust=1, x=0.95))
                         )
    
    t1 <- tableGrob(format(stockSummary), theme = tt, rows = NULL)
    t2 <- tableGrob(format(flowSummary), theme = tt, rows = NULL)
    grid.newpage()
    grid.arrange(t1,t2, nrow=2, ncol=1)
    
    l <- sprintf("Stock summary M%02d", max(period))
    grid.text(label = l,
      x = 0.05, y= 0.95, hjust = 0, vjust = 0,
      gp = gpar(col="black", fill=NA, cex=1.1, font=2)
    )
    grid.lines(x=c(0.05,0.95), y=0.94)

    l <- sprintf("Flow summary M%02d - M%02d", min(period), max(period))
    grid.text(label = l,
      x = 0.05, y= 0.45, hjust = 0, vjust = 0,
      gp = gpar(col="black", fill=NA, cex=1.1, font=2)
    )
    grid.lines(x=c(0.05,0.95), y=0.44)
    l <- sprintf("Source: Stock and flow summary data. Flows averaged over period shown. %1s",
       ifelse(projected, "Projected patients numbers", " Unprojected counts"))
    
    grid.text(
      label = l,
      x = 0.05, y= 0.05,
      hjust = 0, vjust = 0,
      gp = gpar(col="grey60", fill=NA, cex=0.8),
    )
  }
  return(list(stockSummary=stockSummary, flowSummary=flowSummary))
}

# Examples ---------------------------------------------------------------------

if(settings$runExamples){
  plotStockAndFlowSummary(projected = TRUE)
}


```

```{r Visualisation - Plot stock levels, inflows and outflows}

plotStockLevels <- function(stockid              = NULL,
                            projected            = FALSE,
                            x                    = NULL,
                            aggregateNaiveLapsed = TRUE,
                            showInternalFlows    = TRUE
                           )
{  
  if(is.null(stockid)) stockid <- e$en$stocks$id
  if(is.null(x)) x<-1:60
  cols = c("blue", "red", rgb(0,0.7,0))

  p <- function(d1,d2,d3,l,an,h){  
    k <- 0
    for(i in 1:nrow(d1)){
      k <- k + 1
      if(k%%9==1){
        par(mfrow=c(3,3), mar=c(3,4,2,2), oma=c(3,2,6,1))
      }
      ym <- max(d1[i,],d3[i,],d2[i,], na.rm = TRUE) * 1.1
      if(ym==0) ym <- 1
      plot(NA, type = "l",
           ylab="", xlab="", las=1,
           ylim=c(0,ym), xlim = range(x)
           )
      mtext(l[i], side=3, line=0.5, at=grconvertX(0,"npc"), adj=0, cex=0.7,font=2)
      if(!is.null(d1) && sum(d1[i,], na.rm = TRUE)>0){
        lines(x=x,y=d1[i,],lwd=1, col=cols[1])
      }  
      if(!is.null(d2) && sum(d2[i,], na.rm = TRUE)>0){
        lines(x=x,y=d2[i,],lwd=1, col=cols[2])
      }  
      if(!is.null(d3) && sum(d2[i,], na.rm = TRUE)>0){
        lines(x=x,y=d3[i,],lwd=1, col=cols[3])
      }  
      if(!is.null(an)){
        annotation(an[k], 0.06, 0.1, col = "gray30", cex = 1.0)
      }
      if(k %% 9==0 || i==nrow(d1)){
        par(mfrow=c(1,1))
        headerLine(h)
        a <- sprintf("Source: Summary data. %1s ('000), n=%1d",
              ifelse(projected,"Projected patients", "Unprojected counts"),
              nrow(e$s)
              )
        footerLine(a, source = TRUE)
        k <- 0
      }  
    }  
    par(mfrow=c(1,1))
  }  
  
  # Prepare data
  stocks <- e$en$stocks[J(stockid),,on="id"]
  s <- matrix(NA, nrow=nrow(stocks), ncol=length(x))
  fi <- s
  fo <- s
  fs <- s
  ageMean   <- numeric(nrow(stocks))
  gender    <- numeric(nrow(stocks))
  tp <- ifelse(projected, "pats", "n")
  nn <- sprintf("M%02d",x)
  l <- character(nrow(s))
  
  k <- 1
  for(i in 1:nrow(stocks)){
    if(aggregateNaiveLapsed && stocks$id[i] %in% c("S00","S01")){
      if(stocks$id[i] == "S00") next
      n <- c("S00", "S01")
      j <- c(0,1)
      l[k] <- paste("S00/S01 - Naive/Lapsed")
    }else{
      n <- stocks$id[i]
      j <- stocks$id_numeric[i]
      l[k] <- paste(stockid[i], "-", ifelse(nchar(stocks$display_name[i])<24,
                                         stocks$display_name[i], 
                                         stocks$short_name[i]))
    }
    s[k,]  <- colSums(e$ss[entity %in% n & type==tp, ..nn])/1000
    fo[k,] <- colSums(e$fs[from %in% j & !(to   %in% j) & type==tp, ..nn])/1000
    fi[k,] <- colSums(e$fs[to   %in% j & !(from %in% j) & type==tp, ..nn])/1000
    if(showInternalFlows){
      fs[k,] <- colSums(e$fs[from %in% j &  (to   %in% j) & type==tp, ..nn])/1000
    }  
    if( s[k,1] %in% 0) s[k,1]  <- NA
    if(fo[k,1] %in% 0) fo[k,1] <- NA
    if(fi[k,1] %in% 0) fi[k,1] <- NA
    if(fs[k,1] %in% 0) fs[k,1] <- NA
    
    # Age and gender distribution
    sel <-  abs(e$s[,M60]) %in% j
    w <- if(projected) e$pt$pweight[sel] else rep(1,sum(sel))
    if(!is.null(e$pt$age)) ageMean[k]   <- sum(w*e$pt$age[sel]) /sum(w)
    if(!is.null(e$pt$gender)) gender[k] <- sum(w*(e$pt$gender[sel]=="M")) / 
      sum(w*(e$pt$gender[sel] %in% c("F"," M"))) 
    
    k <- k + 1
  }

  #Plot stocks
  opar <- par(no.readonly = TRUE)
  an <- sprintf("Age: %1.1f, M%1.0f/F%1.0f",
          ageMean, 100*gender, 100*(1-gender))
  an[!is.finite(ageMean) | !is.finite(gender)] <- ""
  
  p(s[1:(k-1),], NULL, NULL , l, an, "Stock levels")

  #Plot flows
  p(fo[1:(k-1),], fi[1:(k-1),],fs[1:(k-1),], l,NULL, "Inflows and outflows")
  legend(x=grconvertX(0.8,"npc"),
         y=grconvertY(-0.02,"nfc"),
         legend= c("inflow", "outflow", "internal"), 
         xjust = 1, xpd=NA, horiz=TRUE, 
         fill=cols[c(2,1,3)], 
         border= FALSE, bty="n", cex=0.8, text.col = "gray50")
  
  par(opar)
  
  if(TRUE){
    rownames(s)  <- l
    rownames(fi) <- l
    rownames(fo) <- l
    rownames(fs) <- l
    colnames(s)  <- nn
    colnames(fi) <- nn
    colnames(fo) <- nn
    colnames(fs) <- nn
    return(list(s=s, fi=fi, fo=fo,fs=fs))
  }  
}

# Examples ---------------------------------------------------------------------

if(settings$runExamples){
  l <-plotStockLevels(projected = TRUE,
                  aggregateNaiveLapsed = TRUE
                  )
}

s <- l$s[,1]
for(i in 1:60){
  s <- s + l$fi[,i]-l$fo[,i]
}


```

```{r Visualisation - Plot stock details}

plotStockData <- function(stockId            = NULL,
                          flowPeriod         = 49:60,
                          stockPeriod        = "auto",                          # Interval after first non-zero stock level
                          projected          = FALSE,                           # Projected patients or raw counts
                          internalFlow       = c("normal","first","no","small")[4] # Position internal flows at bottom of chart
                          )

{
  
  if(is.null(stockId)){
    stockId <- with(e$en$stocks, id[which.max(id_numeric)])
  }
  idNumeric <- e$en$stocks[match(stockId, id),id_numeric]
  sn        <- e$en$stocks[match(stockId, id),display_name]
  
  mar        <- c(1.0,1.0,1.5,1.0)*0.04
  header     <- NULL
  footer     <- NULL
  showFrames <- FALSE
  
  sankey <- function(v, vl=NULL,nl=NULL,x0,y0,s=0.03,ch=0.8, w=0.02,cex=0.8,
                     stockcols1 = rgb(1.0,0.5,0.5),
                     stockcols2 = "gray65", 
                     flowcols   = "gray80"
                     )
  {
    if(sum(v)==0) return()
    p <- function(x0,x1,y,h,fill){
        if(length(y)==1) y[2]<-y[1]
        if(length(h)==1) h[2]<-h[1]
        xo <- (x1-x0)/2.5
        y0 <- y[1] +c(1,-1)*h[1]/2
        y1 <- y[2] +c(1,-1)*h[2]/2
      
        x <- c(x0,    x0,    x0+xo, x1-xo, x1, x1, x1-xo, x0+xo)
        y <- c(y0[1], y0[2], y0[2], y1[2], y1[2], y1[1], y1[1], y0[1])
        s <- c(0,0,1,1,0,0,1,1)
        grid.xspline(x, y, shape=s, open=FALSE, 
                     gp=gpar(fill=fill, col=NA)
                     )
      }
    
    if(length(stockcols1)==1){
      stockcols1 <- rep(stockcols1, length.out=length(v))
    }
    if(length(flowcols) ==1){
      flowcols   <- rep(flowcols, length.out=length(v))
    }
    i <- 1:length(v)
    k <- abs(v)/max(abs(v))
    y1 <- k[i]/2 + c(0,cumsum(k+s))[i]
    y2 <- k[i]/2 + c(0,cumsum(k))[i]
    l <- (sum(k)+s*(length(k)-1))/(y0[2]-y0[1])
    k <- k/l
    y1 <- y1/l+y0[1]
    y2 <- y2/l+(y0[1]+y0[2]-sum(k))/2
    
    l<-sign(diff(x0))
    for(j in i){
      p(x0[1]+w/2*l,x0[2]-w/2*l, c(y1[j], y2[j]), k[j]*ch, flowcols[j])
    }
    grid.rect(x0[1],y1,w,k,
              gp=gpar(fill=stockcols1, col=NA)
              )
    grid.rect(x0[2],(y0[1]+y0[2])/2, w,sum(k),
              gp=gpar(fill=stockcols2, col=NA)
              )
    if(is.null(vl)){
      vl <- ifelse(v>=10,sprintf("%1.0f",v), sprintf("%1.1f",v))
    } 
    grid.text((x0[2]+x0[1])/2, y=(y1+y2)/2, 
              vjust=0.5, hjust=0.5, gp=gpar(cex=cex),
              label = vl
              )
    
    if(any(!is.null(nl))){
      j <- max(convertWidth(stringWidth(nl),"npc", valueOnly = TRUE))
      j <- ifelse(x0[1]<x0[2], x0[1]-w/2-j, x0[1]+w/2+0.01)
      grid.text(x=j, y=y1, 
                vjust=0.5, hjust=0, gp=gpar(cex=cex, col="gray50"),
                label = nl
      )
    }  
  }

  # Flows ------------------------------------------------------------------------
  
  m <- sprintf("M%02d", flowPeriod)
  tp <- ifelse(projected,"pats","n")
  fi <- e$fs[type==tp & to==idNumeric ,c("from",m), with=FALSE]
  fi[2] <- fi[1]+fi[2]
  fi <- fi[-1]
  if(internalFlow %in% c("first", "small")){
    i <- c(idNumeric,setdiff(fi$from,idNumeric))
    fi <- fi[match(i,from),]
  } else
  if(internalFlow %in% c("no", "")){
    i <- setdiff(fi$from,idNumeric)
    fi <- fi[match(i,from),]
  }
  ni <- e$en$stocks[match(fi[[1]],id_numeric),id]
  fi <- rowMeans(fi[,-1])
  if(projected) fi<-fi/1000
  
  fo <- e$fs[type==tp & from  ==idNumeric ,c("to",m), with=FALSE]
  fo[2] <- fo[1]+fo[2]
  fo <- fo[-1]
  if(internalFlow %in% c("first", "small")){
    i <- c(idNumeric,setdiff(fo$to,idNumeric))
    fo <- fo[match(i,to),]
  }  
  if(internalFlow %in% "no"){
    i <- setdiff(fo$to,idNumeric)
    fo <- fo[match(i,to),]
  }  
  no <- e$en$stocks[match(fo[[1]],id_numeric),id]
  fo <- rowMeans(fo[,-1])
  if(projected) fo<-fo/1000
  
  if(sum(fi)+sum(fo)==0){
    warning("Stock level or flow = 0!")
    return()
  }
  
  # Viewports 

  grid.newpage()
  
  i <- min((1-mar[2]-mar[4]), (1-mar[1]-mar[3]))                                # Inner VP (apply margins)
  vp <- viewport(x= unit(mar[2]+i/2, "npc"),
                  y= unit(mar[1]+i/2, "npc"), 
                  width  = unit(i, "npc"), 
                  height = unit(i, "npc"),
                  name = "innerVP"
                  )
  pushViewport(vp)
  
  if(showFrames){
    grid.rect(0, 0, 1, 1, vjust = 0, hjust = 0,  
              gp=gpar(col="grey80", fill=NA)
              )
  }  
  
  s  <- sum(fi)/max(sum(fi), sum(fo))
  fc <- rep("gray80", length(fi))
  fc[match(stockId,ni)] <- "gray90"
  f <- fi
  if(internalFlow %in% "small") f[match(stockId,ni)] <- sum(f)/20
  
  sankey(f,
         vl         = sprintf("%1.0f",fi),
         nl         = ni,
         x0         = c(0.0,0.2)+0.05,
         y0         = 0.5+c(-1,1)*0.25*s,
         s          = 0.08/s,
         ch         = 0.9,
         w          = 0.02,
         cex        = 0.6,
         stockcols1 = rgb(1.0,0.5,0.5),
         flowcols   = fc
         )
  
  s <-sum(fo)/max(sum(fi), sum(fo))
  fc <- rep("gray80", length(fo))
  fc[match(stockId,no)] <- "gray90"
  f <- fo
  if(internalFlow %in% "small") f[match(stockId,no)] <- sum(f)/20
  
  sankey(f,
         vl         = sprintf("%1.0f",fo),
         nl         = no,
         x0         = c(0.2,0.0)+0.75,
         y0         = 0.5+c(-1,1)*0.25*s,
         s          = 0.08/s,
         ch         = 0.9,
         w          = 0.02,
         cex        = 0.6,
         stockcols1 = rgb(1.0,0.5,0.5), 
         flowcols   = fc
         )
  
  x <- c(0.00,0.00,0.065,0.065,0.09, 0.065, 0.065, 0.00,0.00)
  y <- c(0.00,0.02,0.02,0.035,0.00,-0.035,-0.02,-0.02,0.00)*1.2
  
  s <- e$ss[type==tp & entity %in% stockId,get(sprintf("M%02d", max(flowPeriod)))]
  if(projected) s<-s/1000
  
  grid.polygon(x+0.26,y+0.5, gp=gpar(lwd=2, col=NA, fill="gray80"))
  grid.text(x=0.25+0.09/2,y=0.5,label = sprintf("%1.0f", sum(fi)),
            hjust=0.5, gp=gpar(cex=0.6))
  grid.text(x=0.25+0.09/2,y=0.45,label = sprintf("%1.2f m", sum(fi)/s),
            hjust=0.5, gp=gpar(cex=0.6, col="gray50"))
  
  grid.polygon(x+0.65,y+0.5, gp=gpar(lwd=2, col=NA, fill="gray80"))
  grid.text(x=0.65+0.07/2,y=0.5,label = sprintf("%1.0f", sum(fo)),
            hjust=0.5, gp=gpar(cex=0.6))
  grid.text(x=0.65+0.07/2,y=0.44,label = sprintf("%1.2f m", sum(fo)/s),
            hjust=0.5, gp=gpar(cex=0.6, col="gray50"))

  # Stock ------------------------------------------------------------------------
  
  # Stock level plot
  
  x   <- 1:60
  y   <- as.numeric(e$ss[type==tp  & entity %in% stockId, mget(sprintf("M%02d",x))])
  yn  <- as.numeric(e$ss[type=="n" & entity %in% stockId, mget(sprintf("M%02d",x))])
  if(projected) y <- y/1000
  
  if(sum(y)==0){
    warning("Stock level = 0!")
    return()
  }

  vp <- viewport(x      = unit(0.5, "npc"),
                 y      = unit(0.5, "npc"), 
                 width  = unit(0.30, "npc"), 
                 height = unit(0.27, "npc"),
                 name   = "stockVP"
                )
  pushViewport(vp)

  grid.text(stockId, 0.05,0.96, hjust=0, vjust=1,
            gp=gpar(font=2, cex=1.0))

    if(stockPeriod %in% "auto"){
    stockPeriod <- match(1, y>0):(60-match(1,rev(y)>0)+1)
    if(any(is.na(stockPeriod))) stockPeriod <- 1:60
  }
  x <- stockPeriod
  y <- y[x]
  
  i   <- y/max(y)*0.8
  grid.polygon(x = (c(x[1],x[1],x,x[length(x)])-x[1])/(x[length(x)]-x[1]), 
               y = c(0,i[1],i,0), 
               gp=gpar(fill=rgb(0.7,0.7,1.0), col=NA))
  
  xf <- intersect(x, flowPeriod)
  yf  <- as.numeric(e$ss[type==tp & entity %in% stockId, mget(sprintf("M%02d",xf))])
  if(projected) yf<-yf/1000
  
  i <- yf/max(y)*0.8
  grid.polygon(x = (c(xf[1],xf[1],xf,xf[length(xf)])-x[1])/(x[length(x)]-x[1]), 
               y = c(0,i[1],i,0), 
               gp=gpar(fill=rgb(0.5,0.5,1.0), col=NA))
  
  if(projected){
    l <- sprintf("Max: %1.0fk (n=%1.0fk)", max(y), max(yn)/1000)
  }else{
    l <- sprintf("Max: %1.0f", max(y))
  }
  
  grid.text(l,
            x=0.95,y=0.96, hjust=1, vjust=1,
            gp=gpar(font=2, cex=0.7, col="gray70"))
  
  grid.text(sprintf("M%02d", c(min(x), max(x))),
            x=c(0,1) ,y=-0.05, hjust=0.5, vjust=1,
            gp=gpar(cex=0.7, col="gray70"))
  
  grid.rect(0.50,0.50,1.0,1.0, 
            gp=gpar(lwd=2, col="gray70", fill=NA)
            )
  
  # Header and footer ------------------------------------------------------------
  
  upViewport()
  
  if(is.null(header)){
    header <- sn
  }  
  if(header!=""){
    grid.text(
      label = header,
      x = 0, y= 1,
      hjust = 0, vjust = 1,
      gp = gpar(col="black", fill=NA, cex=1.4, font=2)
    )
  }  
  
  if(is.null(footer)) footer <- "Footnote"
  
  l <- e$en$stocks[-match("S00",id),.(id,short_name)]
  l <- paste(sapply(1:nrow(l), function(i) sprintf("%1s:%1s",l[i,1], l[i,2])), collapse = ", ")
  grid.text( 
    label = l,
    x = 0, y=0.03, hjust = 0, vjust = 0,
    gp = gpar(col="grey60", fill=NA, cex=0.8),
  )
  
  l <- ifelse(projected, "Projected patient numbers ('000)", "Unprojected counts")
  l <- paste0(l,sprintf(". Flows: M%02d-M%02d, Stocks: M%02d-M%02d",
            min(flowPeriod), max(flowPeriod), min(stockPeriod), max(stockPeriod)))
  
  grid.text( 
    label = l,
    x = 0, y=-0, hjust = 0, vjust = 0,
    gp = gpar(col="grey60", fill=NA, cex=0.8),
  )
  
  return(NULL)
}

# Examples ---------------------------------------------------------------------

if(settings$runExamples){

  plotStockData("S02")

  if(FALSE){
    fn <- "stock data.pdf"
    pdf(fn, width = 8.58, height=6.75)
    for(n in setdiff(e$en$stocks$id, "S00")){
      plotStockData(stockId = n)
    }
    dev.off()
    system2('open', args = paste0("'",fn,"'"), wait = FALSE)
  }  
}


```

```{r Visualisation - Plot flow matrix}

plotFlowMatrix <- function(stockid    = NULL, 
                           projected  = FALSE, 
                           period     = 2:60,
                           showLines  = TRUE,
                           showMagnitude  = "shading",                               # "shading", "circles"
                           showIds    = FALSE,
                           showNames  = TRUE,
                           scale      = "globalmax"                              # "globalmax", "individual"
                         )
{
  
  if(is.null(stockid)) stockid <- setdiff(e$en$stocks$id_numeric,0)
   
  sid         <- with(e$en$stock, id[match(stockid,id_numeric)])
  sName       <- with(e$en$stock, display_name[match(stockid,id_numeric)])
  sNameShort  <- with(e$en$stock, short_name[match(stockid,id_numeric)])

  if(min(period)<2){
    warning("Flows in M01 not defined. Starting at M02!")
    period <- setdiff(period, 1)
  }
    
  n <- length(stockid)
  m <- sprintf("M%02d",period)
  j <- ifelse(projected, "pats", "n")
  gm <- max(e$fs[type==j, mget(m)])                                             # Global maximum for scaling
  mm <- max(rowMeans(e$fs[type==j,mget(m)]))                                    # Maximum per entity for scaling
  
  opar <- par(no.readonly = TRUE)
  par(mfrow=c(n,n), oma=c(5,4.5,7,2), mar=c(1,1,1,1)*0.2)
  
  for(i in 1:(n*n)){
    j <- as.integer((i-1)/n)+1
    k <- (i-1)%%n+1
    l <- ifelse(projected, "pats", "n")
    f <- as.numeric(e$fs[from==stockid[j] & to==stockid[k] & type==l, mget(m)])
    if(scale=="globalmax"){
      ym <- c(0,gm+1)*1.2
    } else
    if(scale=="individual"){
      ym <- c(0,max(f)+1)*1.2
    }else{
      ym <- 1000
    }
    x <- period 
    plot(NA, type = "l", lwd=1, col="blue",
         ylab="", xlab="", las=1, axes = FALSE, ylim=ym, xlim=range(x))
    if(showMagnitude!=FALSE){
      fm <- mean(f)
      l <- 1-fm/mm*0.2
      if(showMagnitude=="shading"){
        rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4],
             col = rgb(l,l,l))
      } else
      if(showMagnitude=="circles"){
        points(x=grconvertX(0.5,"npc"), y=grconvertY(0.5,"npc"),
               pch=19, cex=8*sqrt(fm/mm), col="gray70")
      }  
      annotation(sprintf("<%1.0f>", fm), 
                 x=0.95, y=0.95, cex=0.8, adj = c(1,1))
    }
    if(showLines){
      lines(x=x, y=f, lwd=1, col="blue")
    }  
    box(col=ifelse((i-1)%%n==as.integer((i-1)/n), "gray10","gray80"))
    if(showIds){
      annotation(sprintf("F%1s_%1s",sid[j],sid[k]),
                 x=0.05, y=0.95, cex=0.8, adj = c(0,1))
    }  
  }  
  text(sid,
       xpd=NA, adj=c(0.5,0.5), srt=90, cex=1.2,
       x=grconvertX(-0.02,"nic"), y=grconvertY((n:1)/n-1/n/2, "nic")
      )
  text(sid,
       xpd=NA, adj=c(0.5,0.5), srt=0, cex=1.2,
       x=grconvertX((1:n)/n-1/n/2,"nic"), y=grconvertY(1.02, "nic")
      )
  text("<- from",
       xpd=NA, adj=c(0,0.5), srt=90, cex=0.9, col="gray50",
       x=grconvertX(-0.02,"nic"), y=grconvertY(0.97, "nic")
      )
  text("to ->",
       xpd=NA, adj=c(0,0.5), srt=0, cex=0.9, col="gray50",
       x=grconvertX(0,"nic"), y=grconvertY(1.02, "nic")
      )
  if(showNames){
    text(sNameShort,
         xpd=NA, adj=c(0.5,1.5), srt=0, cex=0.9, col="gray50",
         x=grconvertX((1:n)/n-1/n/2,"nic"), y=grconvertY(0.0, "nic")
        )
    text(sNameShort,
         xpd=NA, adj=c(0.5,0.5), srt=270, cex=0.9, col="gray50",
         x=grconvertX(1.01,"nic"), y=grconvertY((1:n)/n-1/n/2, "nic")
        )
    
  }
  par(mfrow=c(1,1), oma=c(4,4.5,7,2), mar=c(1,1,1,1)*2)
  headerLine(sprintf("Flows M%02d-M%02d", min(period), max(period)))
  a <- sprintf("Source: Summary data. %1s ('000/month)", 
        ifelse(projected,"Projected patients", "Unprojected counts"))
  if(showMagnitude=="shading" && showMagnitude=="lines"){
    a <- paste0(a,". Gray scale represents mean value of flow")
  }else 
  if(showMagnitude=="circles"){
    a <- paste0(a,". Area of circle represents mean value of flow")
  }
  footerLine(a, source = TRUE)
  par(opar)
}  

# Examples ---------------------------------------------------------------------

if(settings$runExamples){
  plotFlowMatrix(projected = TRUE)
  plotFlowMatrix(projected = TRUE, showLines = FALSE, showMagnitude = "circles")
  #plotFlowMatrix(projected = TRUE, showLines = FALSE, showMagnitude = "shading")
}

```

```{r Visualisation - Plot Rx-events}

plotRxEvents <- function(drugIds     = NULL,
                         projected   = FALSE,
                         minPatients = 1000,
                         maxPlots    = NULL
                        )
{  
  if(is.null(drugIds)) drugIds <- e$en$drugs$drug_id
  
  drugIds <- data.table(drugIds)
  setnames(drugIds,"drug_id")
  drugIds <- e$en$drugs[drugIds,, on="drug_id"]
  
  l <- integer(nrow(drugIds))
  for(n in 1:nrow(drugIds)){
    a <- paste0("rx_", drugIds$rname[n])
    if(exists(a,envir = e$rx, inherits = FALSE) ){
       l[n] <- sum(get(a, envir = e$rx, inherits = FALSE)>0)
    }
  }
  drugIds$n <- l
  drugIds <- drugIds[order(-n),]
  patientCountBelowThreshold <- drugIds[n<minPatients, drug_id]
  drugIds <- drugIds[n>=minPatients,]
  
  opar <- par(no.readonly = TRUE)
  k <- NULL
  x <- 1:60
  m <- sprintf("M%02d",x)
  
  nmax <- nrow(drugIds)
  if(!is.null(maxPlots)) nmax <- min(maxPlots, nmax)
  for(i in 1:nmax){
    if(i%%9==1){
      par(mfrow=c(3,3), mar=c(3,4,2,2), oma=c(3,2,6,1))
    }
    a <- paste0("rx_",drugIds$rname[i])
    if(exists(a,envir = e$rx, inherits = FALSE)){
      v <- get(a,envir = e$rx, inherits = FALSE)
      j <- which(v>0)
      v <- v[j]
      if(projected){
        w <- e$pt$pweight[j]
      }else{
        w <- 1.0
      }
      y <- integer(60)
      for(j in 1:60){
        y[j] <- sum(int64ToBitVector(v,j)*w)
      }
      if(projected){
        y <- y/1000
      }
      plot(x=x,y=y, type = "l", lwd=1, col="blue",
           ylab="", xlab="", las=1,
           ylim=c(0,max(y))*1.1
      )
      mtext(drugIds$generic_name[i], side=3,line=0.5,at=0, adj=0, cex=0.7,font=2)
      if(projected){
        l <- sprintf("%1.fk, %1.1f%% (n=%1d)",
                     sum(w)/1000, sum(w)/sum(e$pt$pweight)*100, length(v))
      }else{
        l <- sprintf("n=%1d, %1.1f%%",length(v), length(v)/nrow(e$pt)*100)
      }
      annotation(paste0("Patients ever: ",l),x=0.05,y=0.1)
    }  
    if(i%%9==0 || i==nmax){
      par(mfrow=c(1,1))
      a <- "Patients by drug"
      if(nmax>9){
        a <- paste(a, sprintf("(%1d of %1d)", 
                as.integer((i-1)/9)+1,as.integer(nrow(drugIds)/9)+1))
        print(a)
        headerLine(a)
      }
      
      a <- ifelse(projected,"Projected patients ('000)", "Unprojected counts")
      l <- patientCountBelowThreshold
      k <- ""
      if(length(l)>0){
        if(length(l)>10){
          k <- paste(paste(l[1:10], collapse = ","), "and", length(l)-10, "others")
        } else{
          k <- paste(l, collapse = ",")
        }
        k <- sprintf(". Drugs with with <%1d patients: %1s", minPatients, k)
      }
      footerLine(paste0(a,k), source = TRUE)
    }  
  }  
  par(mfrow=c(1,1))
  par(opar)
}

# Examples ---------------------------------------------------------------------

if(settings$runExamples){
  plotRxEvents(projected   =  TRUE,
               minPatients = 1,
               maxPlots    = NULL)
  if(FALSE){
    fn <- "Rx events.pdf"
    pdf(fn, width = 8.58, height=6.75)
    plotRxEvents(projected   =  TRUE,
                 minPatients = 1,
                 maxPlots    = NULL)
    dev.off()
    system2('open', args = paste0("'",fn,"'"), wait = FALSE)
    rm(fn)
  }
}


```

```{r Visualisation - Episode duration}

# Calculate and plot persistence curves -----------------------------------------------------------------------------------------

episodeDuration <- function(v,                                                  # Input event vector
                            episodeSelect        = NULL,                        # Parameter list to filter episodes
                            maxEpisodePerPatient = 16,                          # Max no of episode per patient (speed, memory..)
                            minTotalEpisodes     = 200,                         # Min number of episodes to attempt fitting 
                            fitModel             = 3,                           # See code
                            fitPoints            = NULL,                        # NULL: use all available, selected: e.g. 5:20
                            projected            = FALSE,
                            weightedFit          = TRUE,                        # Weight fit by contributing sample number?
                            plot                 = TRUE,                        # Plot results
                            showCohorts          = TRUE,                        # Show individual monthly cohorts as overlay
                            showSimpleExpFit     = FALSE,                       # Show single exponential fit curve on graph
                            showAnnotations      = "auto",                      # Position of annotations, F:off
                            showSampleSize       = TRUE,                        # Plot size of contributing sample by month
                            header               = NULL,
                            footer               = NULL,
                            debug                = TRUE
                           )
{
  if(length(v)!=nrow(e$pt)){
    warning("Input vector has to be of lenght of patient data!")
    return(NULL)
  }
  p <- v>0
  if(length(v)==0 || sum(p)==0){
    warning("Input vector is empty!")
    return(NULL)
  }
  v <- v[p]                                                                     # XXX avoid making copies for large data
  
  # Detect episodes ------------------------------------------------------------
  
  n0 <- length(v)
  l <- matrix(0L, nrow=length(v), ncol = 2*maxEpisodePerPatient+3)
  for (i in 60:1){
    if(n0>1e4) cat(".")
    k <- int64ToBitVector(v,i)
    l[k==1 & l[,1]==0,1] <- 61
    l[k==0 & l[,1]==0,1] <- i
    for(j in seq(2,2*maxEpisodePerPatient+2,2)){
      l[k==1 & l[,j-1]>i & l[,j-1]!=0 & l[,j]  ==0, j]   <- i 
      l[k==0 & l[,j]  >i & l[,j]  !=0 & l[,j+1]==0, j+1] <- i 
    }
  }  
  
  episodes <- data.table()

  for (j in 1:maxEpisodePerPatient){
    k <- (l[,(j*2L)]-l[,(j*2L)+1]>0)
    if(sum(k>0)){
      episodes <- rbind(episodes, data.table(
              patId              = e$pt$patient[p][k],
              pweight            = e$pt$pweight[p][k],
              episode            = j,
              lapseBeforeEpisode = l[k,(j*2)+1]-l[k,(j*2)+2],
              startOfEpisode     = l[k,(j*2)+1]+1,
              episodeDuration    = l[k,(j*2)]-l[k,(j*2)+1],
              lapseAfterEpisode  = ifelse(l[k,(j*2)-1]==61,0,l[k,(j*2)-1]-l[k,(j*2)]))
      )
    }  
  }
  a <- episodes[,.(x=max(episode)), keyby=patId]
  episodes <- a[episodes,,on="patId"]
  episodes <- setnames(episodes,"x", "firstEpisode")

  colOrder <- c(setdiff(names(episodes), "firstEpisode"), "firstEpisode")
  setcolorder(episodes, colOrder)

  if(n0>1e4) cat("\n")
  
  # Select episodes ------------------------------------------------------------
  
  # Defaults if no filter criteria are provided
  
  if(is.null(episodeSelect)) episodeSelect <- list()
  if(is.null(episodeSelect$episodeNumber        )) episodeSelect$episodeNumber         <- 0
  if(is.null(episodeSelect$minEpdiodeDuration   )) episodeSelect$minEpdiodeDuration    <- 1
  if(is.null(episodeSelect$maxEpdiodeDuration   )) episodeSelect$maxEpdiodeDuration    <- 60
  if(is.null(episodeSelect$minLapseAfterEpisode )) episodeSelect$minLapseAfterEpisode  <- 2
  if(is.null(episodeSelect$minLapseBeforeEpisode)) episodeSelect$minLapseBeforeEpisode <- 2
  if(is.null(episodeSelect$minEpisodeStart      )) episodeSelect$minEpisodeStart       <- 1
  if(is.null(episodeSelect$maxEpisodeStart      )) episodeSelect$maxEpisodeStart       <- 50

  if(episodeSelect$episodeNumber[1]==0){
    episodeSelect$episodeNumber <- 1:maxEpisodePerPatient
  }
  sel <- with(episodes, 
            episode            %in% episodeSelect$episodeNumber &  
            episodeDuration    >=   episodeSelect$minEpdiodeDuration &
            episodeDuration    <=   episodeSelect$maxEpdiodeDuration &
            lapseAfterEpisode  >=   episodeSelect$minLapseAfterEpisode &
            lapseBeforeEpisode >=   episodeSelect$minLapseBeforeEpisode &
            startOfEpisode     >=   episodeSelect$minEpisodeStart &
            startOfEpisode     <=   episodeSelect$maxEpisodeStart
         )
  episodes$selected <- sel
  
  r=list(  
         episodeSelect     = episodeSelect,                                     # Return selection criteria
         episodes          = episodes                                           # and all episodes 
        )

  if(sum(episodes$selected) < minTotalEpisodes){
    warning(sprintf("Insufficient number of episodes! (n= %1d of %1d, %1d total)", 
                  sum(episodes$selected),minTotalEpisodes, nrow(episodes)))
    return(r)
  }
  
  # Calculate and plot persistence ---------------------------------------------

  if(plot!=FALSE){
    if(plot!="add"){
      par(mfrow=c(1,1), mar=c(5,4,4,2), oma=c(1,0,1,0), pty="m")
    } 
    x <- 1:(60-episodeSelect$minEpisodeStart)
    plot(NA, 
         xlim=c(0,max(x)), xlab="",
         ylim = c(0,1.05), las=1, ylab="", cex.axis=0.9
    )
    if(plot!="add"){
      #abline(h=0, col="gray50", xpd=FALSE)
      mtext("[months]",side=1, line=2.5)
    }  
  }  

  n0  <- numeric(60)                                                            # Size of cohort, cumulative (pats)
  n1  <- numeric(60)                                                            # Remaining, cumulative (pats)
  n2  <- numeric(60)                                                            # Size of cohort (pats)
  n0n <- integer(60)                                                            # Size of cohort, cumulative (count)
  n2n <- integer(60)                                                            # Size of cohort (count)

  for(i in with(episodeSelect, minEpisodeStart:maxEpisodeStart)){
    
    sel <- episodes$selected & episodes$startOfEpisode==i
    k <- factor(episodes$episodeDuration[sel], levels = 1:59)
    if(projected){
      w <- episodes$pweight[sel]
    }else{
      w <- rep(1, sum(sel))
    }
    h <- tapply(w, k, FUN=sum, default = 0)
    j1 <- sum(h) - c(0,cumsum(h[1:(60-i-1)]))
    j0 <- sum(h)

    n1[1:(60-i)] <- n1[1:(60-i)] + j1
    n0[1:(60-i)] <- n0[1:(60-i)] + j0
    n2[i] <- j0

    if(plot!=FALSE && showCohorts){
      lines(x=1:(length(j1))-1, y=j1/j0, col="gray70")
    }
    
    j0 <- sum(sel)                                                              # Remember counts for sample size footnotes
    n0n[1:(60-i)] <- n0n[1:(60-i)] + j0
    n2n[i] <- j0
  }

  # Select fit points 
  
  x <- 0:59
  y <- n1/n0
  if(weightedFit %in% TRUE){
    w <- n0
  }else{
    w <- rep(1,length(x))
  }
  if(is.null(fitPoints)) fitPoints <- 0:59
  fitPoints <- setdiff(fitPoints,which(is.na(y) | is.nan(y)))
  x <- x[fitPoints]
  w <- w[fitPoints]
  y <- y[fitPoints]
  {
    r$curve <- list()
    r$curve$starts    <- n0
    r$curve$remaining <- n1
    r$curve$x         <- x
    r$curve$y         <- y
    r$curve$fitpoints <- fitPoints
  }  
  if(plot!=FALSE){
    #lines(x=x, y=y, type="l", lwd=2, col="blue")
    points(x=x, y=y, pch=19, col="gray50", cex=0.5)
  }  
  if(any(y %in% 0)){
    warning("All episodes end before end of selection window! Zeros ignored")
    x <- x[y>0] 
    w <- w[y>0]
    y <- y[y>0] 
  }

  f1 <- lm(log(y)~x)                                                            # Simple log fit
  
  j <- 6                                                                        # If at least j months data are available..
  if(length(x>=2L*j)){
    ff <- lm(log(y[1:j])~x[1:j])                                                # Attempt to fit to first and seconcond 
    fs <- lm(log(y[j:length(y)])~x[j:length(x)])                                # part of input to generete start values
    start <- list(a1 = 1-exp(predict(ff)[j]),                                   # for NLS
                  b1 = -ff$coefficients[2], 
                  a2 = exp(predict(ff)[j]),
                  b2 = -fs$coefficients[2],
                  c  = 0
                 )
  }else{
    start <- list(a1=exp(f1$coefficients[1]),                                   # if not, fit a single log curve
                  b1 = -f1$coefficients[2], 
                  b2 = 0, 
                  c  = 0
                 )
  }
  if(fitModel==1){
    modelDescription <- "Dual exponential with constant term"
    f <- as.formula("y~a1*exp(-x*b1)+a2*exp(-x*b2)+c")
  } else
  if(fitModel==2){
    modelDescription <- "Dual exponential, without constant term"
    f <- as.formula("y~a1*exp(-x*b1)+a2*exp(-x*b2)")
    start[["c"]] <- NULL
  } else
  if(fitModel==3){
    modelDescription <- "Dual exponential, constrained weights"
    f <- as.formula("y~a1*exp(-x*b1)+(1-a1)*exp(-x*b2)")
    start[["a2"]] <- NULL
    start[["c"]] <- NULL
  } else
  if(fitModel==4){
    modelDescription <- "Triple exponential, without constant term"
    f <- as.formula("y~a1*exp(-x*b1)+a2*exp(-x*b2)+a0*exp(-x*b0)")
    start[["c"]] <- NULL
    start[["a0"]] <- 0.3
    start[["b0"]] <- 1.0
  }
  
  try(f2 <- nls(f, 
                start=start, 
                lower=0,
                weights = w,
                control = list(warnOnly = T), 
                algorithm = "port")
      )

  if(showSimpleExpFit){
    lines(x=x,y=exp(f1$coefficients[1]+x*f1$coefficients[2]) , 
          lwd=2, col=rgb(0,0.7,0), xpd=F)
  }
  
  r$modelSimpleExponential <- f1
  r$model                  <- f2
  r$modelFormula           <- f
  r$modelDescription       <- modelDescription

  if(plot!=FALSE){
    
    i <- seq(0,max(which(n0>0)), length.out=100)
    lines(x=i,y=predict(f2,list(x=i)), lwd=1, col=rgb(0.0,0.0,1.0), xpd=F)
    i <- fitPoints
    lines(x=i,y=predict(f2,list(x=i)), lwd=2, col=rgb(0.0,0.0,1.0), xpd=F)
    ym <- 0.94
    xm <- 0.5
    if(showAnnotations == "auto"){
      if(y[as.integer(length(y)/2)]>0.5) {
        showAnnotations <- "bottomright"        
      } else{
        showAnnotations <- "topleft"
      }
    }
    if(showAnnotations=="topright")    {xm <- 0.52; ym <- 0.96}
    if(showAnnotations=="topleft")     {xm <- 0.00; ym <- 0.96}
    if(showAnnotations=="bottomright") {xm <- 0.52; ym <- 0.50}
    if(showAnnotations=="bottomleft")  {xm <- 0.03; ym <- 0.50}
    yp <- 0
    if(showAnnotations!= FALSE){
      annotation(paste("Model: ",gsub(" ","",deparse(f2$m$formula()))),
                 x=xm+0.00,y=ym-(yp<-yp+1)*0.04, cex=0.8)
      if(!f2$convInfo$isConv){
        annotation("Fit did not converge!",
                   x=xm+0.00,y=ym-(yp<-yp+1)*0.04, cex=0.8, col="red")
      }
      if(!is.null(f2)){
        l <- NULL
        try(l <- summary(f2))
        if(!is.null(l)){
          for(i in 1:nrow(l$coefficients)){
            yp<-yp+1
            j <- sprintf("%1s = %1.3f (t=%1.1f)", row.names(l$coefficients)[i], 
                         l$coefficients[i,1], l$coefficients[i,3])
            annotation(j, x=xm+0.02,y=ym-(yp)*0.04, cex=0.8)
            if(substr(j,1,1)=="b"){
              j <- sprintf("Lifetime = %1.2f months", 1/l$coefficients[i,1])
              annotation(j, x=xm+0.20,y=ym-(yp)*0.04, cex=0.8)
            }
          }
        }else{
          for(i in 1:length(coefficients(f2))){
            yp<-yp+1
            j <- sprintf("%1s = %1.3f", 
                         names(coefficients(f2))[i], 
                         coefficients(f2)[i])
            annotation(j, x=xm+0.02,y=ym-(yp)*0.04, cex=0.8)
          }  
        }  
      }
      annotation(sprintf("Simple exponential lifetime: %1.1f months",
                         -1/coef(f1)[2]),
                 x=xm+0.00,y=ym-(yp<-yp+1)*0.04, cex=0.8)
      annotation(sprintf("Actual first-month dropout: %1.2f",
                         1-(n1/n0)[2]),
                 x=xm+0.00,y=ym-(yp<-yp+1)*0.04, cex=0.8)
      if(!(showSampleSize %in% FALSE)){
        if(showSampleSize %in% TRUE || showSampleSize=="cohort"){
          i <- with(episodeSelect, minEpisodeStart:maxEpisodeStart)
          x <- grconvertX((i-episodeSelect$minEpisodeStart+1)*0.03,"npc")
          y <- n2n[i]
          l <- "Sample size by cohort:"
        }else{
          i <- (1:60)[n0>0]-1
          x <- i
          y <- n0n[i+1]
          l <- "Contributing sample:"
        }
        text(label = l,
             x=-0.40, y=0.15, xpd=TRUE, cex=0.7, adj=c(0,0), col="gray50")
        text(x=x, y=0.02,
             label = sprintf("%1d", i),
             srt=90, cex=0.7, adj=0, col="gray50")
        text(x=x, y=0.05,
             label = sprintf(": %1d", y),
             srt=90, cex=0.7, adj=0, col="gray50")
      }  
    }
    if(plot!="add"){
      if(is.null(header)){
        header <- "Fraction of patients remaining on treatment"
      } 
      headerLine(header)
      footerLine(paste(sprintf("Episodes starting M%02d-M%02d",
                episodeSelect$minEpisodeStart, episodeSelect$maxEpisodeStart),
        ifelse(projected,  "Projected patients", "Unprojected counts"),        
        ifelse(weightedFit,"Weighted fit", "Unweighted fit"),
                       sprintf("%1d episodes, %1d unique patients", 
                         sum(sel), length(unique(episodes$patId[sel]))),
                 sep = ". "),
        source = TRUE)
    }  
  }
  
  # Debug output ---------------------------------------------------------------
  
  if(debug){
    cat("\n")
    dbprint(strrep("-",80))
    dbprint(gsub(" ","",deparse(f)))
    dbprint(modelDescription)
    dbprint(strrep("-",80))
    dbprint(sprintf("%1d episodes detected", nrow(episodes)))
    dbprint(sprintf("%1d episodes (%1.2f%% of episodes) from", 
                  i<-sum(sel), i/nrow(episodes)*100))
    dbprint(sprintf("%1d patients (%1.2f%% of patients) with:", 
                  j<-length(unique(episodes$patId[sel])), 
                  j/length(e$pt$patient)*100), quote=FALSE)
    dbprint(sprintf("   episode start in or after     : M%02d "   , 
                  episodeSelect$minEpisodeStart))
    dbprint(sprintf("   episode start in or before    : M%02d"    , 
                  episodeSelect$maxEpisodeStart))
    dbprint(sprintf("   latest episode for patient    : %1d"      , 
                  min(episodeSelect$episodeNumber)))
    dbprint(sprintf("   first episode for patient     : %1d"      , 
                  max(episodeSelect$episodeNumber)))
    dbprint(sprintf("   min episode duration          : %1d month", 
                  episodeSelect$minEpdiodeDuration))
    dbprint(sprintf("   max episode duration          : %1d month", 
                  episodeSelect$maxEpdiodeDuration))
    dbprint(sprintf("   min lapse before episode      : %1d month", 
                  episodeSelect$minLapseBeforeEpisode))
    dbprint(sprintf("   min lapse after episode       : %1d month", 
                  episodeSelect$minLapseAfterEpisode))
    dbprint(strrep("-",80))
    dbprint(with(episodeSelect, sprintf("Sample size by cohort (M%02d-M%02d):",
          minEpisodeStart, maxEpisodeStart)))
    dbprint(paste(n2n[with(episodeSelect,minEpisodeStart:maxEpisodeStart)],
                   collapse=","))
    dbprint(strrep("-",80))
    cat("\n")
  }
  return(r)
}

# Examples ----------------------------------------------------------------------------------------------------------------------

if(settings$runExamples){
  
  # Lifetime of stocks, comparison to flow based lifetime ----------------------
  
  stockId       <- "S06"                                                        # Select stock
  episodeStart  <- 20:40                                                        # Time range for episode starts

  n  <- e$en$stocks$id_numeric[match(stockId, e$en$stock$id)] 
  v  <- bitArrayToInt64(1L*(abs(e$s[,M01:M60])==n))
  sn <- e$en$stocks$display_name[match(stockId, e$en$stock$id)]
 
  # Persistence curve ----------------------------------------------------------
    
  episodeSelect <-list(
                        episodeNumber         = 0,                              # 1:last, 2: one before last.., 0: any
                        minEpdiodeDuration    = 1,
                        maxEpdiodeDuration    = 60,
                        minLapseAfterEpisode  = 0,                              # Leave at 0 to avoid truncating episodes
                        minLapseBeforeEpisode = 1,                              # Usually 2 or 3 months
                        minEpisodeStart       = min(episodeStart),              # First month selected episodes can start
                        maxEpisodeStart       = max(episodeStart)               # First month selected episodes can start
         )
  
  l <- episodeDuration( v,
                        episodeSelect        = episodeSelect,
                        fitModel             = 2,                               # 3: Dual exponential, constrained weights
                        fitPoints            = NULL, 
                        weightedFit          = TRUE,
                        projected            = TRUE,    
                        maxEpisodePerPatient = 16,
                        plot                 = TRUE,
                        showCohorts          = TRUE,
                        showSimpleExpFit     = TRUE,
                        showSampleSize       = "contribution",
                        showAnnotations      = "topright",
                        header               = paste(stockId, "-", sn),
                        footer               = NULL,
                        debug                = TRUE,
                      )
}

 # Patient examples -----------------------------------------------------------

  if(FALSE){
    id <- sample(with(l$episodes, patId[selected]),50)
    mapBitVector(v=v[match(id,e$pt$patient)],
                 id = id,
                 vlines = range(episodeStart), 
                 header = paste(stockId, "-", sn),
                 markers =  l$episodes$startOfEpisode[l$episodes$selected]
                              [match(id,l$episodes$patId[l$episodes$selected])]
                 )
  }
  
suppressWarnings(rm(n,v,sn,stockId,episodeStart))
  
```

```{r Visualisation - Stock lifetime summary}

plotStockLifetime <-    function(stockIds                    = NULL,
                                 episodeSelect               = NULL,
                                 period                      = 20:40,           # Range of episodes starts
                                 projected                   = TRUE,
                                 model                       = 2,               # 2: dual exp, free parameters
                                 generateLifetimeComparison  = TRUE,
                                 plotStockAndFlowLifetimes   = TRUE,
                                 generateSummaryTable        = TRUE,
                                 generateExamplePages        = TRUE,
                                 debug                       = TRUE
                                 )
{

  # Other settings
  aggregateNaiveLapsed <- TRUE
  showInternalFlows    <- FALSE
  
  if(!exists("episodeDuration")) 
      stop("Requires function episodeDuration!")
  if(generateExamplePages & !exists("mapBitVector")) 
      stop("Requiresfunction mapBitvector!")
  
  if(is.null(episodeSelect)){
    episodeSelect <-list( episodeNumber         = 0,                            # 1:last, 2: one before last.., 0: any
                          minEpdiodeDuration    = 1,
                          maxEpdiodeDuration    = 60,
                          minLapseAfterEpisode  = 0,                            # Leave at 0 to avoid truncating episodes
                          minLapseBeforeEpisode = 1,                            # Usually 2 or 3 months
                          minEpisodeStart       = min(period),                  # First month selected episodes can start
                          maxEpisodeStart       = max(period)                   # First month selected episodes can start
                       )
  }

  if(!is.null(period)){
    episodeSelect$minEpisodeStart <- min(period)
    episodeSelect$maxEpisodeStart <- max(period)
  }
  if(is.null(stockIds)){
    stockIds <- setdiff(e$en$stocks$id, "S00")                                  # Explode 'naive', but include 'lapsed'
  }
  stocks <- e$en$stocks[match(stockIds,id),]
  r <- list()                                                                   # Return object
  noConvergence <- list()                                                       # Stocks for which model did not converge
  modelFormula  <- "<none>"

  opar <- par(no.readonly = TRUE)
  nn <- 0
  for(i in 1:nrow(stocks)){
    if(nn%%9==0){
      par(mfrow=c(3,3), mar=c(3,4,2,2), oma=c(3,2,6,1))
    }
    
    v <- bitArrayToInt64(abs(e$s[,M01:M60])==stocks$id_numeric[i])
    header <- with(stocks, paste(id[i],"-", ifelse(nchar(display_name[i])<25, 
                         display_name[i], stocks$short_name[i])))
    dbprint(sprintf("Processing: %1s (n=%1d)", header, sum(v>0)))
    suppressWarnings(
      l <- episodeDuration(v,
                           episodeSelect        = episodeSelect,
                           fitModel             = model,                        # 3: Dual exponential, constrained weights
                           projected            = projected,                    # Projected patients or sample count 
                           fitPoints            = NULL,                         # NULL: Use all available
                           weightedFit          = TRUE,                         # Weight by initial size of cohort
                           maxEpisodePerPatient = 16,                           # Max look back depth, earlier episodes ignored
                           minTotalEpisodes     = 200,                          # Min number of episodes to attempt fitting
                           plot                 = "add",                        # "add": for use in summary grid plots
                           showCohorts          = TRUE,                         # Plot cohort lines
                           showSimpleExpFit     = FALSE,                        # Don't show simple exponential fit line
                           showSampleSize       = FALSE,                        # Don't show sample size sub-plots
                           showAnnotations      = FALSE,                        # Don't show annotations in plots
                           debug                = FALSE,                        # Suppress debug output
                         )
    )
    if(!is.null(l$modelFormula)){
      modelFormula <- gsub(" ","",deparse(l$modelFormula))
    }  
    if(!is.null(l$model) && l$model$convInfo$isConv){
      a <- ""
      try(a <- summary(l$model)$coefficients[,"Estimate"], silent = TRUE)
      for(j in 1:length(a)){
        i1 <- names(a)[j]
        if(substr(i1,1,1)=="b"){
          i1 <- paste0("1/",i1)
          i2 <- sprintf("= %1.1fm", 1/a[j])
        }else{
          i2 <- sprintf("= %1.2f", a[j])
        }
        annotation(i1, x=0.62, y=0.98-0.08*j)
        annotation(i2, x=0.74, y=0.98-0.08*j)
      }
      j <- j+1
      annotation("n", x=0.62, y=0.98-0.08*j)
      annotation(sprintf("= %1d",sum(l$episodes$selected)), 
                 x=0.74, y=0.98-0.08*j)
      mtext(header, side=3,line=0.5,at=0, adj=0, cex=0.7,font=2)
      nn <- nn+1
    }else{
      noConvergence <- append(noConvergence,stocks$id[i])
    }

    # Return objects
    r[[stocks$id[i]]] <- list(simpleExponential = l$modelSimpleExponential, 
                              model             = l$model)
    k <- which(l$episodes$selected==TRUE)
    if(length(k)>0){
      k <- sample(k, min(50,length(k)))
      r[[stocks$id[i]]]$exampleEpisodes <- l$episodes[k,]
      r[[stocks$id[i]]]$sampleSize <- 
          list(episodesN    = sum(l$episodes$selected),
               episodesProj = sum(l$episodes[selected==TRUE,pweight]),
               patsN        = length(unique(l$episodes[selected==TRUE,patId]))
          )
    }

    if(nn!=0 && (nn%%9==0 || i==nrow(stocks))){
      par(mfrow=c(1,1))
      a <- "Episode duration - Cohorts starting"
      if(min(period) == max(period)){
        a <- paste(a, sprintf("M%02d", min(period)))
      }else{
        a <- paste(a, sprintf("M%02d-M%02d", min(period),max(period)))
      }
      headerLine(a)
      
      ft <- paste0("Model: '", modelFormula,"'. ",
                   ifelse(projected,"Projected.", "Unprojected."))
      if(length(noConvergence)>0){
        ft <- paste0(ft,paste("No convergence:", 
                            paste(noConvergence, collapse = ", ")))
      }
      footerLine(ft,source = TRUE)
    }  
  }
  par(opar)
  cat("\n")
  
  r$episodeSelect <- episodeSelect
  r$noConvergence <- noConvergence
  r$config <- list(sid       = stockIds,
                   model     = model,
                   projected = projected
                  )

  # Lifetime comparison bar chart ----------------------------------------------
  
  a <- list() 
  for(i in 1:length(stockIds)){
    try(a[[stockIds[i]]] <- 
          c(stockIds[i], as.list(coefficients(r[[stockIds[i]]]$model))))
  }
  a <- rbindlist(a,use.names=TRUE, fill = TRUE)
  setnames(a,1,"id")
  a <- stocks[,.(id, short_name)][a,,on="id"]
  
  r$coefficients <- a
    
  if(generateLifetimeComparison){
    
    opar <- par(no.readonly = TRUE)
    par(mfrow=c(3,1), mar=c(2.5,4.3,3.0,2), oma=c(6,3,6,1))
    cols <- c(rgb(0.5,0.5,1.0),rgb(1.0,0.5,0.5))

    if(is.null(a$a2)) a$a2 <- 1-a$a1
    
    texp <- (a$a1/a$b1+a$a2/a$b2)/(a$a1+a$a2)
    
    t <-barplot(rbind(a$a2,a$a1), las=1, border = NA, col=cols, 
                ylab="share", names.arg = a$id)
    mtext("Share of fast and slow",
          side=3,line=2, at=-0.9,adj = c(0,0), cex = 0.8,font=2 )
    text(t,a$a2/2 ,sprintf("%1.2f",a$a2))
    text(t,a$a2+a$a1/2,sprintf("%1.2f",a$a1))
    text(t,a$a2+a$a1,sprintf("%1.2f",a$a1+a$a2), 
                         xpd=TRUE, adj=c(0.5,-0.6), col="gray50")
  
    t <-barplot(1/a$b1, las=1, border = NA, col=cols[2], 
                ylab="months", names.arg = a$id)
    mtext("Lifetime fast",
          side=3,line=2, at=-0.9,adj = c(0,0), cex = 0.8,font=2 )
    text(t,1/a$b1/2,sprintf("%1.2f",1/a$b1))
    
    t <-barplot(1/a$b2, las=1, border = NA, col=cols[1], 
                ylab="months" , names.arg = a$id)
    mtext("Lifetime slow",
          side=3,line=2, at=-0.9,adj = c(0,0), cex = 0.8, font=2)
    text(t,1/a$b2/2,sprintf("%1.2f",1/a$b2))

    par(oma=c(4.0,3,6,1))
    
    l <- ifelse(!is.na(texp), sprintf("%1.2f",texp), "")
    text(t,grconvertY(-0.1,"npc"),l, xpd=TRUE,col="gray50")
    text(grconvertX(0,"npc"),grconvertY(-0.1,"npc"),"texp:", 
         adj = c(1,0.5), xpd=TRUE, col="gray50")

    par(mfrow=c(1,1))
  
    headerLine("Stock lifetimes")
    footerLine(paste(paste0(a$id,": ", a$short_name), collapse = ", "), 
               y=-0.9, cex = 0.6)
    footerLine(ft, y=0, source = TRUE)

    par(opar)
  }  
  
  # Stock and flow based lifetimes ---------------------------------------------
  
  tp <- ifelse(projected, "pats","n")
  scale <- ifelse(projected, 1/1000,1)
  n <- sprintf("M%02d",1:60)
  
  s <- e$ss[J(stockIds),,on="entity"][type==tp,]                                # Stock totals
  if(aggregateNaiveLapsed){
    set(s,1L,n,s[entity=="S01",..n]+e$ss[entity %in% "S00" &type==tp, M01:M60])
  }
  set(s,NULL,n,s[,..n]*scale)

  fi <- matrix(NA,nrow = nrow(stocks), ncol=60)
  fo <- fi
  fs <- fi
  for(i in stocks$id_numeric){
    if(aggregateNaiveLapsed && i==1) ii <- c(0,1) else ii <- i
    fo[i,] <- colSums(e$fs[from %in% ii & !(to   %in% ii) & type==tp,..n])*scale
    fi[i,] <- colSums(e$fs[to   %in% ii & !(from %in% ii) & type==tp,..n])*scale
    fs[i,] <- colSums(e$fs[to   %in% ii &  (from %in% ii) & type==tp,..n])*scale
  }
  fo <- data.table(stockIds,fo)
  setnames(fo, c("entity",n))
  fi <- data.table(stockIds,fi)
  setnames(fi, c("entity",n))
  fs <- data.table(stockIds,fs)
  setnames(fs, c("entity",n))
  
  if(debug){
    if(projected){
      k <- sapply(stockIds, function(x) r[[x]]$sampleSize$episodesProj)
    }else{
      k <- sapply(stockIds, function(x) r[[x]]$sampleSize$episodesN)
    }  
    k <- sapply(k,function(x) ifelse(is.null(x),0,x))*scale
    k <- rowSums(fi[,mget(sprintf("M%02d", period))])/k
    i <- 0.001
    if(any((abs(k-1) > i) %in% TRUE)){
      k <- k[is.finite(k)]
      j <- paste("Episode count inconsistent with inflow rates!",
                     sprintf("(Max deviation %1.2f%%)",max(abs(k-1)*100))
                )
      warning(j)
      dbprint(j)
      dbprint("Check that 'maxEpisodePerPatient' is suffient to capture all episodes")
      cat("\n")
      dbprint(k)
    }else{
      dbprint(paste("Episode count consistent with inflow rates!",
                     sprintf("(deviation < %1.2f%%)",i*100)))
    }
  }  

  # Plot graphs    
  
  x <- 1:60
  if(plotStockAndFlowLifetimes){

    for(i in 1:nrow(stocks)){
      if(i%%9==1){
        par(mfrow=c(3,3), mar=c(3,4,2,2), oma=c(3,2,6,1))
      }
      yi <- unlist(s[entity==stocks$id[i], M01:M60]/                            # Inflows
                         fi[entity==stocks$id[i], M01:M60])
      yo <- unlist(s[entity==stocks$id[i], M01:M60]/                            # Outflows
                         fo[entity==stocks$id[i], M01:M60])
      if(showInternalFlows){
        ys <- unlist(s[entity==stocks$id[i], M01:M60]/                          # Internal flows
                           fs[entity==stocks$id[i], M01:M60])
      }else{
        ys <- rep(NA,length(yi))
      }  
    
      suppressWarnings(
        yl <- max(max(0,yo[is.finite(yo)], na.rm = TRUE),
                  max(0,yi[is.finite(yi)], na.rm = TRUE),
                  max(0,ys[is.finite(ys)], na.rm = TRUE)
                 )
      )
      if(!is.finite(yl)) yl <- 1.0
      plot(NA, type = "l", lwd=1, col="blue",
           ylab="", xlab="", las=1,
           xlim= range(x),
           ylim=c(0,yl)*1.1
          )
      
      if(TRUE){
        j <- r$coefficients[match(stocks$id[i],id),3:ncol(r$coefficients)]
        if(is.null(j$a2)) j$a2 <- 1-j$a1
        texp <- (j$a1/j$b1+j$a2/j$b2)/(j$a1+j$a2)
        lines(x=period,y=rep(texp, length(period)), 
              type = "l", lwd=3, col="gray70")
      }
      lines(x=x,y=yi, type = "l", lwd=1, col="red")
      lines(x=x,y=yo, type = "l", lwd=1, col="blue")
      lines(x=x,y=ys, type = "l", lwd=1, col=rgb(0.0,0.7,0.0))
      
      legend(x=grconvertX(0.05,"npc"),y=grconvertY(0.3,"npc"),
             legend = c(sprintf("inflow  : %1.2f m", 
                                mean(yi[is.finite(yi)], na.rm = TRUE)),
                        sprintf("outflow : %1.2f m", 
                                mean(yo[is.finite(yo)], na.rm = TRUE)),
                        sprintf("texp      : %1.2f m", 
                                texp)
                        ),
             fill   = c("red", "blue", "gray70"),
             xjust = 0, xpd=NA, horiz=FALSE, 
             border= FALSE, bty="n", cex=0.8, text.col = "gray50"
            )

      l <- paste(stockIds[i], "-", ifelse(nchar(stocks$display_name[i])<24,
                                          stocks$display_name[i], 
                                          stocks$short_name[i])
                 )
      if(aggregateNaiveLapsed && i==1){
        l <- "S00/S01 - Naive/Lapsed"
      }
      mtext(l, side=3,line=0.5,at=0, adj=0, cex=0.7,font=2)
      
      if(i%%9==0 || i==nrow(stocks)){
        par(mfrow=c(1,1))
        l <- "Inflow and outflow lifetimes"
        if(nrow(stocks)>9){
          l <- paste(l, sprintf("(%1d of %1d)",
                  as.integer((i-1)/9)+1,as.integer(nrow(stock)/9)+1))
        }
        headerLine(l)
        l <- paste0("Stock and flow summary data. ",
              ifelse(projected,"Projected patient numbers ('000)", 
                               "Unprojected counts"),
              ". Stock/flow lifetime averages in months for M01-M60."
              )
        footerLine(l, source = TRUE)
      }
    }  
    par(mfrow=c(1,1))
    par(opar)  
  }
  
  # Summary table --------------------------------------------------------------
  
  if(generateSummaryTable){  

    tp <- ifelse(projected,"pats","n")
    s <- e$ss[J(stockIds),,on="entity"][type==tp,                               # Stock totals
                                        mget(sprintf("M%02d",period))]
    g <- 12*coefficients(lm(t(s)~period))[2,]                                   # Growth rate (pats/mounts)
    s <- rowMeans(s)
    g <- g/s                                                                    # CAGR
    fi <- fo <- integer(nrow(stocks))
    for(i in stocks$id_numeric){
      fo[i] <- sum(rowMeans(e$fs[from %in% i & to!=i & type==tp,               # Inflows and outflows
                                 mget(sprintf("M%02d",period))]))               # Exclude internal flows!!
      fi[i] <- sum(rowMeans(e$fs[to %in% i & from!=i & type==tp,
                                 mget(sprintf("M%02d",period))]))
    }
    scale <- ifelse(projected, 1/1000,1)
    j <- ifelse(projected, 1,0)
    n <- sapply(stockIds, function(x){i <- r[[x]]$sampleSize$episodesN
                                      ifelse(is.null(i),0,i)
                                     }
                ) 
    lifetimeTable <- data.table('stock ID' = stocks$id, 
                                'episodes' = n,
                                'stock'    = round(s*scale,j),
                                'sCAGR'    = g, 
                                'inflow'   = round(fi*scale,j), 
                                'outflow'  = round(fo*scale,j),
                                's/fi'     = s/fi, 
                                's/fo'     = s/fo, 
                                'texp'     = (a$a1/a$b1+a$a2/a$b2)/(a$a1+a$a2)
                                )
    if(debug){
      cat("\n")
      dbprint(strrep("-",80))
      dbprint("Lifetime summary")
      dbprint(strrep("-",80))
      dbprint(format(lifetimeTable, digits=3, width=8, scientific=FALSE))
      dbprint(strrep("-",80))
    }
    
    r$lifetimeTable <- lifetimeTable
    
    tt <- ttheme_default(base_size = 10, padding = unit(c(8,3),"mm"),
                         core=list(fg_params=list(hjust=1,x=0.95)),
                         colhead=list(fg_params=list(hjust=1, x=0.95))
                         )
    t <- tableGrob(format(lifetimeTable, digits=3, width=8),
                   theme = tt, rows = NULL)
    grid.newpage()
    grid.draw(t)

    l <- sprintf("Comparison of stock lifetimes M%02d - M%02d", 
                 min(period), max(period))
    grid.text(label = l,
      x = 0.05, y= 0.92, hjust = 0, vjust = 0,
      gp = gpar(col="black", fill=NA, cex=1.1, font=2)
    )
    l <- ifelse(projected, 
                "Projected patient numbers ('000)",
                "Unprojected counts"
                )
    l <- paste0(l,". Lifetimes in month",
                ". Weighted lifetime (texp) = (a1/b1+a2/b2)/(a1+a2)")
    grid.text(
      label = l,
      x = 0.05, y= 0.05,
      hjust = 0, vjust = 0,
      gp = gpar(col="grey60", fill=NA, cex=0.8),
    )  
    rm(s,g,fi,fo,l,t,tt,k)
  }

  # Show patient examples ------------------------------------------------------
  
  if(generateExamplePages){
    
    if(exists("mapBitVector")){
      for(n in 1:length(stockIds)){
        k <- r[[stockIds[n]]]$exampleEpisodes
        if(nrow(k)>=50){
          i <- sample.int(nrow(k),50)
          id <- k$patId[i]
          m  <- k$startOfEpisode[i]
          p <- match(id, e$pt$patient)
          v <- bitArrayToInt64(1L*(abs(e$s[p,M01:M60])==stocks$id_numeric[n]))
          mapBitVector(v, id=id, 
                       vlines = range(period),
                       markers = m,
                       header = paste(stockIds[n],"-", stocks$display_name[n])
                      )
        }  
      }      
    }else{
      warning("Could not find mapBitVector function!")
    }
  }
  
  return(r)
}

# Example ----------------------------------------------------------------------

if(settings$runExamples){

  # generatePDFs <- TRUE  
  # if (generatePDFs){
  #   fn <- paste(settings$pathTemp, "test.pdf", sep="/")
  #   pdf(file=fn, width=10, height=7)
  # }
  l <- plotStockLifetime(generateExamplePages = FALSE)
  # if (generatePDFs){
  #   dev.off()
  #   system2('open', args = paste0("'",fn,"'"), wait = FALSE)
  # }
}

```

```{r Visualisation - Pathways}

plotPathways <- function(stockId                = NULL,
                         removeInClassSwitch    = TRUE,                         # Simplify pathways by removing switches in the same AC
                         removeLapsePeriods     = TRUE,                         # Simplify pathways by removing lapse periods
                         collapsePrePostLapse   = TRUE,                         # Simplify pathways by collapsing same AC either side of lapse
                         showExamples           = FALSE,
                         debug                  = TRUE
                        )
{
  
  if(is.null(stockId)){
    stockId <- e$en$stocks[id_numeric %in% max(id_numeric), id]
  }
  id  <- e$en$stocks[id %in% stockId,id_numeric][1]
  sel <- rowSums(abs(e$s[,M01:M60])==id)>0
  s   <- as.matrix(e$s[sel, M01:M60])
  m1  <- matrix(0L, nrow = nrow(s), ncol=60)                                    # Pathway by patient (most recent first)
  m2  <- matrix(0L, nrow = nrow(s), ncol=60)                                    # Length of episodes
  k  <- integer(nrow(s))
  l1 <- integer(nrow(s))
  l2 <- integer(nrow(s))
  
  for (i in 60:1){                                                              # Identify episodes
    cat(".")
    for(j in 1:nrow(s)){
      if(l1[j]==0 & abs(s[j,i])==id){
        l1[j] <- 1
        l2[j] <- i                                                              # Last month on target stock
        m1[j,l1[j]] <- abs(s[j,i])
        m2[j,l1[j]] <- m2[j,l1[j]] + 1
      } else if(l1[j]>0){
        if((abs(s[j,i])!=m1[j,l1[j]]) || 
           (!removeInClassSwitch && (s[j,i]==m1[j,l1[j]]) && 
            (abs(s[j,i-1])==m1[j,l1[j]]))){
          l1[j] <- l1[j] + 1 
          m1[j,l1[j]] <- abs(s[j,i])
          if(s[j,i]!=0) m2[j,l1[j]] <- 1
        } else {
          if(s[j,i]!=0) m2[j,l1[j]] <- m2[j,l1[j]] + 1
        }
      }
    }
  }
  cat("\n")
  rm(i,j,l1)

  if (removeLapsePeriods){                                                      # Remove lapse periods
    for (i in 1:nrow(m1)){
      l1 <- m1[i,]
      l2 <- m2[i,]
      m1[i,] <- 0
      m2[i,] <- 0
      k <- l1>1
      j <- sum(k)
      m1[i,1:j] <- l1[k]
      m2[i,1:j] <- l2[k]
    }
    rm(l1,l2,k,j)
  }  
  
  if(collapsePrePostLapse){                                                     # Collapse episodes if same class either side of lapse
    n <- nrow(s)
    l1 <- integer(n)
    l2 <- rep(1,n)
    r <- 1:n
    
    for(i in 2:60){
      k <- m1[r+l2*n]>0 & m1[r+l1*n] == m1[r+l2*n]
      j <- r[k]+l1[k]*n
      m2[j] <- m2[j] + m2[r[k]+l2[k]*n]
      
      l1[r[!k]] <- l1[r[!k]] + 1
      m1[r[!k]+l1[!k]*n] <- m1[r[!k]+l2[!k]*n]
      k <- m1[r+l2*n]==0
      
      j <- r[k]+l1[k]*n
      m1[j] <- 0
      m2[j] <- 0
      l2 <- l2 + 1
      cat(".")
    }
    rm(n,l1,l2,r,k,j)
  }  

  p <- character(nrow(s))                                                       # Collate pathway strings
  for (j in 1:nrow(m1)){
    p[j] <- paste0(rev(m1[j,m1[j,]>0]), collapse = "")
  } 
  rm(j)
  rownames(m1) <- p 
  rownames(m2) <- p 
  
  pf <- table(p)
  pf <- pf[order(pf, -sapply(names(pf),nchar), decreasing=TRUE)]                # Frequency of different path ways

  m3 <- matrix(0L, nrow = length(pf), ncol=60)                                  # Average length of episode by pathway
  rownames(m3) <- names(pf)
  for(i in 1:sum(pf>1)){
    if(i%%1000==0) cat(".")
    j <- m2[p %in% names(pf)[i],,drop=F]
    m3[i,] <- colMeans(j)
  }
  cat("\n")
  
  if(debug){
    dbprint(sprintf("Patients ever been on stock '%1s'  : %1d",  stockId, nrow(s)))
    dbprint(sprintf("Number of different pathways       : %1d",  length(pf)))
  }

  x <-25:1
  y <- pf[x]/sum(pf[x], na.rm = TRUE)
  par(mar=c(5,8,4,18), oma=c(1,2,0,0))
  t <- barplot(y, horiz = T, border = NA,xlab = "",
               cex.axis = 0.8, names.arg = "")
  par(mar=c(5,4,4,2))
  text(x=grconvertX(0,"nfc"), y=t, xpd=T, adj = 0, cex=0.8,
       labels = names(pf)[x])
  text(x=y, y=t, xpd=T, adj = c(0,0.5), cex=0.8,
       labels = sprintf("  %1.2f%%", y*100))
  l <- rev(cumsum(rev(pf[x])))/sum(pf,na.rm = TRUE)
  l <- ifelse(is.na(l),"",sprintf("%1.1f%%",l*100))
  text(x=grconvertX(0.76,"nfc"), y=t, xpd=T, adj = 0, cex=0.8, labels =  l)
  l <- ifelse(is.na(pf[x]),"",sprintf("%1.0f",pf[x]))
  text(x=grconvertX(0.86,"nfc"), y=t, xpd=T, adj = 0, cex=0.8, labels = l)
  text(x=grconvertX(0.74,"nfc"), y=grconvertY(1,"npc"), xpd=T, adj = 0, cex=0.8,
       labels = "Cumulative")
  text(x=grconvertX(0.84,"nfc"), y=grconvertY(1,"npc"), xpd=T, adj = 0, cex=0.8,
       labels = "Patients")
  
  headerLine(sprintf("Pathways to latest '%1s' episode", stockId))
  
  l <- sprintf("Patients ever been on stock '%1s': %1d",  stockId, nrow(s))
  l <- paste0(l,". Unprojected counts")
  if (removeInClassSwitch)  l <- paste0(l, ". Switches within classes ignored.")
  if (removeLapsePeriods)   l <- paste0(l, " Lapse periods removed.")
  if (collapsePrePostLapse) l <- paste0(l, " Episodes with same class pre- and post lapse ignored.")
  footerLine(l, y=0)
  l <- e$en$stocks[,.(id_numeric, short_name)]
  l <- paste(sprintf("%1s-%1s",l[[1]],l[[2]]), collapse = ", ")
  footerLine(l, y=-1)
  
  if(showExamples){
    x <-min(length(pf),10):1
    for(n in names(pf[x])){
      patIds <- e$pt[sel,patient][p %in% n]
      if(length(patIds)>=50){
        k <-sample.int(length(patIds),50)
      }else{
        k <- c(1:length(patIds), rep(NA,50-length(patIds)))
      }
      l <- ifelse(is.na(patIds[k]),"",patIds[k])
      
      mapPatientHistoryMultiple(id=l, 
                                showinclasschange = FALSE,
                                header = paste0("Patway '", n,"'"),
                                footer = sprintf("Patients (unprojected): %1d",
                                               length(patIds)))
      
    }
  }
}

# ------------------------------------------------------------------------------

if(settings$runExamples){
  plotPathways(stockId = "S06")
}

```

```{r Visualisation - Lines of therapy}

plotLinesOfTherapy <- function(startMonth  = 1,
                               endMonth    = 60,
                               projected   = TRUE,
                               top         = 8,
                               width       = c("equal","patients")[1],
                               legend      = TRUE,
                               debug       = FALSE
                              )
{

  # List of drugs, ordered by patients in a specific month or ever
  
  drugs <- e$en$drugs[!(generic_name %in% c("rx_lapsed", "rx_naive")) 
                      ,.(drug_id, generic_name, rname)]
  l = integer(nrow(drugs))
  for(i in 1:nrow(drugs)){
    n <- paste0("rx_",drugs$rname[i])
    if(exists(n, envir=e$rx)){
      k <- get(n, envir = e$rx)
      l[i] <- sum(k>0)
      #l[i] <- sum(int64ToBitVector(k,60))
    }
  }
  drugs$pats <- l
  drugs <- drugs[order(pats, decreasing=TRUE),]

  if(debug){
    dbprint("Drug - ordered by number of patients ever")
    dbprint(strrep("-",60))
    dbprint(drugs)
  }

  r <- list(drugs=drugs)
  r$projected <- projected
  r$startMonth <- startMonth
  r$endMonth <- endMonth
      
  # Create data structure: drugs in bit positions, int64 blocks for months
  nn <- drugs$rname
  n <- length(nn)
  n2 <- 62                                                                      # drugs per 64-bit integer vector
  n1 <- as.integer(length(nn)/n2+1)                                             # number of vectors per month
  m <- integer64(60*n1*nrow(e$pt))
  dim(m) <- c(nrow(e$pt),60*n1)
  m <- as.data.table(m)
  
  for(i in length(nn):1){
    n0 <- as.integer((i-1)/n2)
    n <- paste0("rx_",nn[i])
    if(exists(n, envir = e$rx)){
      l1 <- get(n, envir = e$rx)
      dbprint(sprintf("%3d of %3d: %s", length(nn)-i+1, length(nn), n))
      for(j in 1:60){
        l2 <- int64ToBitVector(l1,j)
        m[[n1*(j-1)+n0+1]] <- 2 * m[[n1*(j-1)+n0+1]] + l2
        if(nrow(m)>1e6) cat(".")
      }
      if(nrow(m)>1e6) cat("\n")
    }  
  }
  rm(i,l1,l2)
  setnames(m, paste(rep(sprintf("M%02d",1:60), each=n1), rep(1:n1,60), sep=":"))
  
  # Check data: Patients by drug in a single month
  
  if(debug>1){
    
    m0 <- 60
    
    l <- integer(length(nn))
    for(i in 1:length(nn)){
      n0 <- as.integer((i-1)/n2)
      l[i] <- sum(int64ToBitVector(m[[n0 + n1*(m0-1)+1]], i-n2*n0))
    }
    l <- data.frame(nn,n=l)
    l <- l[order(l$n,decreasing=TRUE),]
    row.names(l) <- 1:nrow(l)
    {
      dbprint(sprintf("Patients: M%1d ", m0))
      dbprint(strrep("-",30))
      dbprint(l[1:10,])
      dbprint("")
      
      # Patients by drug in any month
      dbprint("Patients, anytime")
      dbprint(strrep("-",30))
      dbprint(drugs[order(pats, decreasing=TRUE),.(rname,n=pats)][1:10,])
    }
    rm(l,i)
  }
  
  # Unique drug combinations per patient -----------------------------------------
  
  l1 <- integer(nrow(m))                                                        # Combination in first month non zero
  for(i in 1:n1){            
    l1 <- l1 + 1 * (m[[n1*(startMonth-1)+i]]!=0)
  }
  l1 <- 1* (l1>0)
  
  for(m2 in (startMonth+1):endMonth){
    
    l4 <- rep(1,nrow(m))                                                        # Combination m2 is new 
    
    for(m1 in 1:(m2-1)){
      
      l2 <- integer(nrow(m))                                                    # Combinations in m1 and m2 are not equal
      for(i in 1:n1){               
        l2 <- l2 + 1 * (m[[n1*(m1-1)+i]] != m[[n1*(m2-1)+i]])
      }
      l2 <- l2>0
      
      l3 <- integer(nrow(m))                                                    # Combination m2 is not zero
      for(i in 1:n1){ 
        l3 <- l3 + 1 * (m[[n1*(m2-1)+i]]!=0)
      }
      l3 <- l3>0
    
      l4 <- l4 * !(!l2 | !l3)
    }
    l1 <- l1 + 1*(l4>0)
    cat(".")
  }
  cat("\n")
  rm(l2,l3,l4,m1,m2,i)
  
  r$lines <- l1
  
  # Number of combinations  
  # n <- 5 
  # id <- e$pt$patient[sample(which(l1==n),1)]
  # mapPatientHistoryIndividual(id=id)
  
  # Lines of therapy graphs ----------------------------------------------------
  
  if(is.null(top)) top <- 8
  w <- if(projected) e$pt$pweight/1000 else rep(1,nrow(e$pt))
  
  a <- tapply(w, list(lines=l1, stock=abs(e$s[,M60])), 
              length, default = 0)
  r$lines <- a
  avgLines <- sum(as.integer(rownames(a)) * rowSums(a)) / (sum(a))
  if(top<max(l1)){
    a <- rbind(a[1:top,], colSums(a[(top+1):nrow(a),]))
    row.names(a) <- c(row.names(a)[1:top],sprintf("%1d+",top))
  }
  sid <- as.integer(colnames(a))
  colnames(a)  <- e$en$stocks$id[match(sid, e$en$stocks$id_numeric)]
  
  # hist(l1, breaks = max(l1),las=1, border = "white", col="gray70",
  #      ylab = "",  xlab = "Drug combinations")
  
  opar <- par(no.readonly = TRUE)
  par(mar=c(6,2,7,4.5), oma=c(0,2,0,2))
  
  palette <-brewer.pal(n = 9, name = 'Blues')
  col = colorRampPalette(palette[2:7], bias=1)(nrow(a))
  
  v <- t(t(a)/colSums(a))
  if(width=="equal") width = 1 else width = colSums(a)
  t <- barplot(v, border = "white", las=1, width = width,
          space = 0.1, col=col, cex.axis = 0.9, cex.names = 0.9)
  
  y <- a[,ncol(a)]
  y <- (cumsum(y)-y/2)/sum(y)
  l <- sprintf("(%1.1f%%)", rowSums(a)/sum(a)*100)

  if(legend){
    legend(x=grconvertX(0.88, "nfc"), y=grconvertY(0.6,"nfc"),
           legend = rev(paste(row.names(a),l)), cex=0.8,
           col=NA, fill=rev(col), border = NA, bty="n", xpd=TRUE)
  }else{
    text(x=grconvertX(1,"npc"), y = y,
         labels = rownames(a), xpd=TRUE, adj=c(0,0.5), cex=0.8)
    text(x=grconvertX(1.03,"npc"), y = y,
         labels = l, xpd=TRUE, adj=c(0,0.5), cex=0.8)
    segments(grconvertX(0.97,"npc"), y, grconvertX(0.99,"npc"),
             col="gray60")
  }  
  
  text(x=t, y = 1.02, xpd=TRUE, adj=c(0.5,0.0), cex=0.8,
       labels = sprintf("%1.1fk", colSums(a)/1000))
  
  for(i in 1:ncol(a)){
    y <- a[,i]
    y <- (cumsum(y)-y/2)/sum(y)
    l <- sprintf("%1.1f%%", a[,i]/sum(a[,i])*100)
    l[a[,i]/sum(a[,i]) < 0.02] <- ""
    text(x=t[i], y = y,  xpd=TRUE, adj=c(0.5,0.5), cex=0.6, labels = l)
  }
  
  par(mar=c(6,4,7,4))
  mtext(sprintf("Average lines: %1.1f", avgLines), 
        at=grconvertX(0, "nfc"), side=3, line = 2, 
        cex=1.0, adj = 0, col = "gray50")
  
  
  headerLine(sprintf("Number of lines of therapy by therapy stock in M%02d",
                     endMonth))
  n <- e$en$stocks$short_name[match(colnames(a), e$en$stocks$id)]
  
  footerLine(paste(paste(colnames(a),"-",n), collapse = ", "),y=-1)
  l <- if(projected) "Projected patients ('000)" else "Sample count"
  l <- paste0(l, ", n=", nrow(e$pt))
  footerLine(l, source = TRUE)
  
  par(opar)
  
  return(r)

}

# Example ----------------------------------------------------------------------

l <- plotLinesOfTherapy(width="patient")

l$lines

drugs <- l$drugs
l <- l$lines

```

```{r Visualisation - Drugs per patient}


plotDrugsPerPatient <- function(month      = 60,
                                projected  = TRUE,
                                top        = 8,
                                width      = "equal",
                                legend     = TRUE
                                )
{
  drugs <- e$en$drugs[!(generic_name %in% c("rx_lapsed", "rx_naive")) 
                      ,.(drug_id, generic_name, rname)]
  
  r <- list(drugs=drugs)
  
  # Number of drugs per patient
  
  l = integer(nrow(e$pt))
  for(i in 1:nrow(drugs)){
    n <- paste0("rx_",drugs$rname[i])
    if(exists(n, envir=e$rx)){
      k <- get(n, envir = e$rx)
      l <- l + int64ToBitVector(k,60)
    }
  }
  
  r$ndrugs <- l
  
  # hist(l, breaks = max(l))

  if(is.null(top)) top <- 8
  w <- if(projected) e$pt$pweight else rep(1,nrow(e$pt))
  
  m <- sprintf("M%02d", month)
  a <- tapply(w, list(lines=l, stock=abs(e$s[,..m][[1]])), 
              sum, default = 0)

  r$pats <- a
  r$projected <- projected
  r$month <- month
  
  avgLines <- sum(as.integer(rownames(a)) * rowSums(a)) / sum(a)
  if(top<max(l)){
    a <- rbind(a[1:top,], colSums(a[(top+1):nrow(a),]))
    row.names(a) <- c(row.names(a)[1:top],sprintf("%1d+",top))
  }
  sid <- as.integer(colnames(a))
  colnames(a)  <- e$en$stocks$id[match(sid, e$en$stocks$id_numeric)]
  
  # hist(l1, breaks = max(l1),las=1, border = "white", col="gray70",
  #      ylab = "",  xlab = "Drug combinations")
  
  opar <- par(no.readonly = TRUE)
  par(mar=c(6,2,7,4), oma=c(0,2,0,2))
  
  palette <-brewer.pal(n = 9, name = 'Blues')
  col = colorRampPalette(palette[2:7], bias=1)(nrow(a))
  
  v <- t(t(a)/colSums(a))
  if(width=="equal") width = 1 else width = colSums(a)
  t <- barplot(v, border = "white", las=1, width = width,
          space = 0.1, col=col, cex.axis = 0.9, cex.names = 0.9)
  
  y <- a[,ncol(a)]
  y <- (cumsum(y)-y/2)/sum(y)
  
  l <- sprintf("(%1.1f%%)", rowSums(a)/sum(a)*100)

  if(legend){
    legend(x=grconvertX(0.89, "nfc"), y=grconvertY(0.6,"nfc"),
           legend = rev(paste(row.names(a),l)), cex=0.8,
           col=NA, fill=rev(col), border = NA, bty="n", xpd=TRUE)
  }else{
    text(x=grconvertX(1,"npc"), y = y,
         labels = rownames(a), xpd=TRUE, adj=c(0,0.5), cex=0.8)
    text(x=grconvertX(1.03,"npc"), y = y,
         labels = l, xpd=TRUE, adj=c(0,0.5), cex=0.8)
    segments(grconvertX(0.97,"npc"), y, grconvertX(0.99,"npc"),
             col="gray60")
  }  

  text(x=t, y = 1.02, xpd=TRUE, adj=c(0.5,0.0), cex=0.8,
       labels = sprintf(ifelse(projected, "%1.0fk", "%1.1fk"), colSums(a)/1000))
  
  for(i in 1:ncol(a)){
    y <- a[,i]
    y <- (cumsum(y)-y/2)/sum(y)
    l <- sprintf("%1.1f%%", a[,i]/sum(a[,i])*100)
    l[a[,i]/sum(a[,i]) <0.03] <- ""
    text(x=t[i], y = y,  xpd=TRUE, adj=c(0.5,0.5), cex=0.6,
         labels = l)
  }
  
  par(mar=c(6,4,7,4))
  mtext(sprintf("Average number of drugs: %1.1f", avgLines), 
        at=grconvertX(0, "nfc"), side=3, line = 2, 
        cex=1.0, adj = 0, col = "gray50")
  #legend()
  headerLine(sprintf("Number of patients by number of drugs in M%02d",month))
  n <- e$en$stocks$short_name[match(colnames(a), e$en$stocks$id)]
  
  footerLine(paste(paste(colnames(a),"-",n), collapse = ", "),y=-1)
  l <- if(projected) "Projected patients ('000)" else "Sample count"
  l <- paste0(l, ", n=", nrow(e$pt))
  footerLine(l, source = TRUE)
  
  par(opar)
  
  return(r)
}

# Example ----------------------------------------------------------------------

l <- plotDrugsPerPatient(width = "", projected  = FALSE)




```

# Shiny

```{r Shiny - Architecture Map page}

# Define UI 

ui <- fluidPage(

  titlePanel("Market architecture"),                                            # Window title

  tabsetPanel(type = "tabs",
    tabPanel("Plot", 
      br(),
      plotOutput(outputId = "plot",
                 click    = "plot_click",                                       # Allow clicks, can not use on grid  
                 width    = "100%",                                             # Use entire column width
                 height   = "600px",                                            # Height when inline==F
                 inline   = TRUE                                                # use <span>, set size in renderPlot
                 ),                                               
      
      hr(),
      fluidRow(
        column(width = 6, offset = 0,
          sliderInput(inputId = "S01",                                          # Input: Slider
                      label = "S01:",
                      min = 0,
                      max = 1000,
                      value = 500),
          sliderInput(inputId = "S02",                                          # Input: Slider
                      label = "S02:",
                      min = 0,
                      max = 1000,
                      value = 500),
          sliderInput(inputId = "S03",                                          # Input: Slider
                      label = "S03:",
                      min = 0,
                      max = 1000,
                      value = 500),
        ),
        column(width = 6, offset =0,
          sliderInput(inputId = "flows",                                         # Input: Slider
                      label = "Flows:",
                      min = 1,
                      max = 1000,
                      value = 200)
        )  
      ),
      hr(),
      verbatimTextOutput("clickinfo"),                                          # Output for click coordinates
      verbatimTextOutput("dimension_display"),                                  # Output for browser window size
      tags$head(tags$script('                                                       
                                var dimension = [0, 0];
                                $(document).on("shiny:connected", function(e) {
                                    dimension[0] = window.innerWidth;
                                    dimension[1] = window.innerHeight;
                                    Shiny.onInputChange("dimension", dimension);
                                });
                                $(window).resize(function(e) {
                                    dimension[0] = window.innerWidth;
                                    dimension[1] = window.innerHeight;
                                    Shiny.onInputChange("dimension", dimension);
                                });
                            '))                                                 # Javascript code to report window size
    ),
    tabPanel("Patient histories", 
      br(),
      actionButton(inputId  = "newPatientsButton", 
                   label    = "New Patients", 
                   icon     = NULL),
      br(),
      plotOutput(outputId = "patient_histories",
                   click    = "plot_click",                                     # Allow clicks  
                   width    = "100%",                                           # Use entire column width
                   height   = "600px",                                          # Height when inline==F
                   inline   = TRUE                                             # use <span>, set size in renderPlot
                   )
      )
  )
)  

# Content server

server <- function(input, output, session) {
  {
    observeEvent(input$dimension,
    {               
      output$plot <- renderPlot(
        {
          layout$`S00 VALUE`$value = input$S01
          layout$`S02 VALUE`$value = input$S02
          layout$S03$value = input$S03
          for(i in 1:length(layout)){
            if(identical(layout[[i]]$class, "flow")) {
              layout[[i]]$value<-input$flows
            }
          }
          renderArchitectureMap(layout=layout)
          print(".")
        },
        width  = min(input$dimension[1], 1000)*1.0,
        height = min(input$dimension[1], 1000)*0.5,
      )
    })
  }  
  output$clickinfo <- renderPrint({                                             # Show click location 
      cat("Click:\n")
      i <- input$plot_click
      assign("clickInfo", i, envir = globalenv())
      sprintf("x=%1.3f, y=%1.3f", i$x, i$y)
    })
  output$dimension_display <- renderText({                                      # Show browser container dimensions
       sprintf("Window size: x=%1d, y=%1d",
               input$dimension[1], input$dimension[2])
    })
  observeEvent(input$dimension,
  {               
    output$patient_histories <-renderPlot({
      a <- input$newPatientsButton
      mapPatientHistoryMultiple()
      },
      width  = min(input$dimension[1], 1000)*1.0,
      height = min(input$dimension[1], 1000)*0.8
    )
  }
  )
}

shinyApp(ui = ui, server = server)

```

# Model

```{r Model - Initialistion}

modelInitialisation <- function(stocks               = NULL,
                                simSteps             = 98,
                                stockInitPeriod      = 49:60,
                                flowInitPeriod       = 49:60,
                                initType             = "trend",                 # "mean", "trend", "final"
                                lifetimeType         = "fit",                   # "fit" "avg"
                                socDemPeriod         = 60,
                                projected            = TRUE,
                                defaultStockLifeTime = 30,
                                debug                = TRUE
                                )
{
  # Settings -------------------------------------------------------------------
  
  ltfitThreshold <- 0.5
  yScale         <- 0.001
  mfrow          <- 4
  
  # Create model data table ----------------------------------------------------
  
  # Set stocks (historic and additional)
  
  if(is.null(stocks)){
    stocks <- e$en$stocks
  } else
  if(class(stocks)[1]=="character"){
    nn <- intersect(stocks, e$en$stocks$id)
    a  <- e$en$stocks[match(nn, id),]
    nn <- setdiff(stocks, e$en$stocks$id)
    a <- rbind(a,
               data.table(id           = nn,
                          id_numeric   = as.integer(substr(nn,2,3)),
                          display_name = nn,
                          short_name   = nn
                          ),
               fill=TRUE)
  } else
  if(class(stocks)[1]!="data.table"){
    warning("Stock IDs not valid!", call. = FALSE)
    return()
  }

  # Create data table
  if(simSteps>99){
    warning("Error: Maximum simulation time 99 months!")
    return()
  }
  n <- nrow(stocks)
  sid <- stocks$id
  fid <- paste0("F", rep(sid,each=n), "_", rep(sid,n))
  data <- data.table(entity  = c(sid, fid),
                     type    = c(rep("stock",n), rep("flow",n*n)),
                     from    = c(rep(NA,n), rep(stocks$id_numeric,each=n)),
                     to      = c(rep(NA,n), rep(stocks$id_numeric,n)),
                     data    = matrix(0,nrow=n+n*n, ncol = 60+simSteps+1)
  )
  m <- c(sprintf("H%02d",1:60), sprintf("M%02d",0:simSteps))
  setnames(data, (ncol(data)-length(m)+1):ncol(data),m)
  
  # Assign historic stocks to output table
  i <- setdiff(stocks$id, e$en$stocks$id)
  if(debug && length(i)>0){
    warning(paste("Model stock IDs not in historic data:", 
                  paste(sprintf("'%1s'",i),collapse=", ")),
            call. = FALSE)
  }
  tp <- ifelse(projected, "pats", "n")
  a <-e$ss[type==tp, ][match(data$entity, e$ss$entity),]
  set(data, match(a$entity, data$entity), sprintf("H%02d",1:60), a[,M01:M60])
  
  # Assign historic flows to output table
  a <- e$fs[type==tp, ][match(data$entity, e$fs$entity),]
  set(data, match(a$entity, data$entity), sprintf("H%02d",1:60), a[,M01:M60])

  rm(m,a,i,n,tp,sid,fid)

  # Initial stock values -------------------------------------------------------

  if(initType == "mean"){
    m <- sprintf("H%02d", stockInitPeriod)
    v <- rowMeans(data[type=="stock", ..m])
  } else 
  if(initType == "trend"){
    v <- NA
    m <- sprintf("H%02d", stockInitPeriod)
    sid <- data[type=="stock", entity]
    for(i in 1:length(sid)){
      a <- data[type=="stock" & entity %in% sid[i], ..m]
      l <- lm(as.numeric(a)~stockInitPeriod)
      v[i] <- l$fitted.values[length(l)]
    }
  } else
  if(initType == "final"){
    m <- sprintf("H%02d", stockInitPeriod[length(stockInitPeriod)])
    v <- data[type=="stock", ..m][[1]]
  }
  data[type=="stock", "M00":= v]
  
  # Initial flow values --------------------------------------------------------
  
  m <- sprintf("H%02d",flowInitPeriod)
  m <- setdiff(m,"H01")                                                         # Ignore first month for flow averages
  if(initType == "mean"){
    v <- rowMeans(data[type=="flow", ..m])
  } else 
  if(initType == "trend"){
    v <- NA
    fid <- data[type=="flow",entity]
    for(i in 1:length(fid)){
      a <- data[type=="flow" & entity %in% fid[i], ..m]
      l <- lm(as.numeric(a)~stockInitPeriod)
      v[i] <- l$fitted.values[length(l)]
    }
  } else
  if(initType == "final"){
    m <- sprintf("H%02d", flowInitPeriod[length(flowInitPeriod)])
    v <- data[type=="flow", ..m][[1]]
  }
  data[type=="flow", "M00":= v]

  summary <- cbind(data[type=="stock",.(entity,M00)],
                   data[type=="flow",sum(.SD), keyby ="to",   .SDcols="M00"][[2]],
                   data[type=="flow",sum(.SD), keyby ="from", .SDcols="M00"][[2]]
                  )
  setnames(summary, 2:4, c("stock", "inflow", "outflow"))
  rm(m,v)

  # Outflow lifetimes ----------------------------------------------------------

  # Averages over stock- and flow init period
  
  summary <- cbind(summary, ltavg=rep(NA, nrow(summary)))
  summary$ltavg <- summary$stock/summary$outflow
  
  # Lifetime based on fit model
  
  summary <- cbind(summary, ltfit=rep(NA, nrow(summary)))
  
  if(debug){                                                                    # Plot debug charts
    opar <- par(no.readonly = TRUE)
    par(mfrow=c(mfrow,3), mar=c(3,5,2,2), oma=c(3,2,6,0))
  }  
  
  k <- 0
  for(i in 1:nrow(summary)){
    k <- k+1
    
    # Selected stock levels and outflows
    sid <- summary$entity[i]
    m <- names(data)[grepl("^H[0-9]{2}", names(data))]
    m <- setdiff(m,"H01")                                                       # Ignore H01, flow invalid
    fo <- as.numeric(colSums(data[grepl(paste0("^F", sid ,"_"),entity), ..m]) )
    s  <- as.numeric(data[entity==sid,..m])
    x0 <- as.integer(substr(m,2,4))
    y <- s/fo

    # Fit exponential model 
    sel <- s > ltfitThreshold * mean(s, na.rm=TRUE) & s>0                       # Ignore values with low stock levels in fit
    x <- x0[sel]
    y <- (fo/s)[sel]
    fm <- "y~a*exp(-x*b)+c"    
    l <- NULL
    suppressWarnings(
      tryCatch(l <- nls(as.formula(fm), 
                    start=c(a=y[1], b=1/12, c=0), 
                    lower=0,
                    weights = s[sel],
                    control = list(warnOnly = TRUE), 
                    algorithm = "port"),
               error = function(e) e
          )
    )
    if(!is.null(l)){
      ltEstimate <- 1/predict(l)[length(x)]
    } else{
      ltEstimate <- NA
      warning(paste0("Fit to naive stock level failed! (", sid,")"),
              call. = FALSE)
    }

    if(debug && !is.null(l)){                                                   # Plot debug charts
       
      plot(x=x0, y=s*yScale, type='l', col="gray50", las=1,
           ylab="", xlab="", main = "",
           ylim = c(0, max(s*yScale, na.rm = TRUE))*1.1)
      lines(x=x, y=s[sel]*yScale, col="blue", lwd=2)
      title(paste(sid, "Stock level", sep=" - "), adj=0)
  
      plot(x=x0, y=fo*yScale, type='l', col="gray50", las=1,
           ylab="", xlab="", main = "",
           ylim = c(0, max(fo*yScale, na.rm = TRUE))*1.1)
      lines(x=x, y=fo[sel]*yScale, col="blue", lwd=2)
      title(paste(sid, "Outflow", sep=" - "), adj=0)

      plot(x=x0, y=fo/s, type='l', lwd=1, las=1, cex=0.6, col="gray50",
           ylab="", xlab="", main = "",
           ylim = c(0, max(fo/s, na.rm = TRUE))*1.2)
      lines(x=x, y=y, col="blue", lwd=2)
      lines(x=x, y=predict(l), col="red", lwd=2)
      title(paste(sid, "Incidence estimate", sep=" - "), adj=0)

      a <- coefficients(l)[3]
      annotation(sprintf("Fit:   %1.3f/month (%1.1f months)",1/ltEstimate, ltEstimate), 
                 x=0.04, y=0.30-0.05*4/mfrow, col="darkred")
      annotation(sprintf("Avg: %1.3f/month (%1.1f months)", a<-1/summary$ltavg[i], 1/a),
                 x=0.04, y=0.24-0.12*4/mfrow, col="green")
      abline(h=1/summary$ltavg[i], col="green", lwd=2)
      abline(h=1/ltEstimate, col="red", lwd=2)
      
    }
    if(debug && (k%%mfrow==0 || i==nrow(summary))){
      op <- par(no.readonly = TRUE)
      par(mfrow=c(1,1))
      footerLine(paste("Projected patient numbers, fit model:", fm), source = TRUE)
      headerLine("Outflow lifetimes")
      par(op)
      k <-0
    } 
    summary$ltfit[i] <- ltEstimate
  }
  if(debug) par(opar)

  # Select lifetimes used 
  summary <- cbind(summary, lifetime=rep(NA, nrow(summary)))
  
  if(lifetimeType =="avg"){
    summary$lifetime <- summary$ltavg
  } else
  if(lifetimeType =="fit"){
    summary$lifetime <- summary$ltfit
  }else{
    with(summary,
         lifetime <- ltfit,
         lifetime[is.na(lifetime)] <- ltavg[is.na(lifetime)]
         )
  }
  if(any(k <- !is.finite(summary$lifetime))){
  l <- paste(paste0("'",summary$entity[k],"'"), collapse = ", ")
  l <- paste0("Non-finite stock lifetimes. Replacing with defaults: ",l)
  warning(l, call. = FALSE)
  summary$lifetime[k] <- defaultStockLifeTime
  }

  # Switch matrix - Share of outflows ------------------------------------------

  sm <- matrix(NA, nrow=nrow(stocks), ncol=nrow(stocks))
  for(i in 1:nrow(stocks)){
    j <- data[from %in% stocks$id_numeric[i] & type=="flow", M00]
    sm[i,] <- j/sum(j)
  }
  colnames(sm) <- paste0("share of outflow.", stocks$id);

  if(any(k <- apply(sm, 1, function(x) !any(is.finite(x))))){
    warning("Switch matrix contains non-finite values. Replacing with 1/ncol",
            call. = FALSE)
    sm[k] <- 1/ncol(sm)
  }
  if(!(all(abs(rowSums(sm)-1.0)<1e-7))){
    warning("Switch matrix row totals != 1. Re-normalising",
            call. = FALSE)
    sm <- t(t(sm)/rowSums(sm))
  }
  summary <- cbind(summary, sm)
  rm(k, sm)
  
  # Age, gender and mortality --------------------------------------------------
  
  summary$age       <- NA
  summary$male      <- NA
  summary$female    <- NA
  summary$mortality <- NA
  
  if(is.null(e$pt$age) || is.null(e$pt$gender)){
    warning("Age and/or gender information missing!", call. = FALSE)
  } else{
    for(i in 1:nrow(stocks)){
      sel    <- abs(e$s[, M60]) == stocks$id_numeric[i]
      w <- if(projected) e$pt$pweight[sel] else rep(1,sum(sel))
      summary$age[i]    <- sum(w*e$pt$age[sel], na.rm = TRUE)/sum(w, na.rm = TRUE)
      summary$male[i]   <- sum(w*(e$pt$gender[sel] %in% "M"), na.rm = TRUE)/
                           sum(w*(e$pt$gender[sel] %in% c("M","F")), na.rm = TRUE)
      summary$female[i] <- sum(w*(e$pt$gender[sel] %in% "F"), na.rm = TRUE)/
                           sum(w*(e$pt$gender[sel] %in% c("M","F")), na.rm = TRUE)

      if(projected){
        a <- e$pt[sel,.(n=sum(pweight)), by=c("gender","age")]
      }else{
        a <- e$pt[sel,.(n=length(pweight)), by=c("gender","age")]
      }  
      a <- e$mort[a, .(age, gender, Males, Females, n), on="age"]
      summary$mortality[i] <- sum(a$n * ifelse(a$gender=="M", a$Males, a$Females))/ sum(a$n)
    }
    rm(a,w,sel)
  }
  
  # Replacing age, gender and mortality with means where missing
  k <- !is.finite(summary$age)
  if(any(k)){
    summary$age[k] <- with(summary, sum(stock[!k] * age[!k])/sum(stock))
    warning("Non-finite age values. Replacing with averages of finite values",
            call. = FALSE)
  }
  k <- !is.finite(summary$male)
  if(any(k)){
    summary$male[k]   <- with(summary, sum(male[!k])/sum(stock[!k]) * stock[k])
    summary$female[k] <- with(summary, sum(female[!k])/sum(stock[!k]) * stock[k])
    warning("Non-finite gender counts. Replacing with averages of finite values",
            call. = FALSE)
  }
  k <- !is.finite(summary$mortality)
  if(any(k)){
    summary$mortality[k] <- with(summary, sum(stock[!k] * mortality[!k])/sum(stock))
    warning("Non-finite mortality values. Replacing with averages of finite values",
            call. = FALSE)
  }

  # Metadata ---------------------------------------------------------------------
  
  info <- list()
  
  info$simSteps             <- simSteps
  info$stockInitPeriod      <- stockInitPeriod
  info$flowInitPeriod       <- flowInitPeriod
  info$socDemPeriod         <- socDemPeriod
  info$initType             <- initType
  info$defaultStockLifeTime <- defaultStockLifeTime

  # Model data set ---------------------------------------------------------------
  
  model <- new.env()
  model$en$stocks <- stocks
  model$data      <- data
  model$summary   <- summary
  model$info      <- info
  rm(stocks, data, summary)
  
  if(debug){
    l <- model$summary
    names(l) <- gsub("share of outflow", "sof",names(l))
    dbprint(strrep("-",158))
    dbprint(sprintf("Initial stock and flow values: '%1s'", initType))
    dbprint("Summary")
    dbprint(strrep("-",158))
    dbprint(format(l, digits=4, width=6))
    dbprint(strrep("-",158))
  }
  
  return(model)
}  


# Examples ---------------------------------------------------------------------

if(settings$runExamples){
  # Stock table has to have the same format as historical stock table:
  stocks <- rbind(e$en$stocks, 
                  list("S10", 10, "", "Danuglipron","Danu","GLP1 Oral","#FF3300",""))

  # Alternatively, a list of stock IDs can be provided:
  # stocks <- c(e$en$stocks$id, "S10")
  
  model <- modelInitialisation(stocks = stocks,
                               debug  = TRUE
                               )
  rm(stocks)
}  


```

```{r Model - Plot stocks and flows}

modelPlotEntities <- function(model                = NULL,                      # Model environment
                              entities             = NULL,                      # NULL: All stocks and flows
                              period               = NULL,                      # String with column names
                              highlightModelTrace  = TRUE,
                              mfrow                = NULL, 
                              header               = NULL,
                              footer               = NULL,
                              debug                = FALSE
                             )
{ 
  # Settings 
  yScale <- 0.001
  if(is.null(mfrow)) mfrow <- c(3,3)
  
  # Entities
  d <- model$data
  stocks <- model$en$stocks
  if(is.null(entities)){
    entities <- d$entity
  }else
  if(length(entities)==1 && entities == "stocks"){
    entities <- d[type=="stock", entity]
  }else
  if(length(entities)==1 && entities == "flows"){
    entities <- d[type=="flow", entity]
  }

  # Period
  m <- names(d)[grep("^[H,M][0-9]{2}", names(d))]
  if(length(period)==2){
    m <-m[match(period[1],m):match(period[2],m)]
  }else
  if(!is.null(period)){
    m <- period
  }
  x0 <- as.integer(gsub("H","", m[grep("^H",m)]))                               # Timeline for historic data
  x1 <- as.integer(gsub("M","", m[grep("^M",m)]))                               # Timeline for future data
  x  <- c(x0-61, x1)                                                            # Unified timeline (H60=M0=0)

  # Generate plots
  opar <- par(no.readonly = TRUE)
  k <- 0
  for(i in 1:length(entities)){
    
    k <- k+1
    if(k%%prod(mfrow)==1){
      mv <- if(mfrow[1]<=3) c(3,2) else c(3,1)
      mh <- if(mfrow[2]<=3) c(4,2) else c(4,1)
      par(mfrow=mfrow, mar=c(mv[1],mh[1],mv[2],mh[2]), oma=c(3,2,6,1))
    }
    
    # Values
    if(entities[i] =="S00/S01"){
      y <- colSums(d[entity %in% c("S00", "S01"), ..m]) * yScale
      tp <- "stock"
      lbl <- paste(entities[i], "- Naive/Lapsed")
    } else{
      y <- as.numeric(d[entity==entities[i], ..m]) * yScale
      tp <- d[entity==entities[i], type]
      if(length(tp)==0) tp<-"none"
      if(tp =="stock"){
        j <- match(entities[i],stocks$id)
        lbl <- paste(entities[i], "-",ifelse(nchar(stocks$display_name[j])<24,
                                             stocks$display_name[j], 
                                             stocks&short_name[j]))
      } else{
        lbl <- entities[i]
      }
    }
    if(y[1] %in% 0.0) y[1] <- NA
    if(any(!is.na(y)) && sum(abs(y), na.rm = TRUE)>0){
      yl <- c(0, max(y, na.rm = TRUE)) * 1.1
    }else{
      yl <- c(0, 1)
    }
    plot(NA, type = "l",
         ylab="", xlab="", las=1,
         ylim= yl, xlim=range(x)
        )
    if(0 %in% x) abline(v=0, lwd=2, col="red")
    mtext(lbl, side=3,line=0.5, at=grconvertX(0,"npc") , adj=0, cex=0.7,font=2)
    
    if(highlightModelTrace){
      col = c("gray50", "blue")
      lwd = c(1, 2)
    } else {
      col = c("blue", "blue")
      lwd = c(1, 1)
    }
    if(sum(y,na.rm = TRUE)>0){
      if(length(x0)>0){
        j <- 1:length(x0)
        lines(x=x[j+1],y=y[j], lwd=lwd[1], col=col[1])                          # Last month of history (M60) = M00!
      }
      if(length(x1)>0){
        j <- length(x0) + 1:length(x1)
        lines(x=x[j],y=y[j], lwd=lwd[2], col=col[2])
      }  
    }
    
    if(k%%prod(mfrow)==0 || i==length(entities) || 
       (i>1 && tp!=d[entity==entities[i+1],type])){
      
      par(mfrow=c(1,1))
      if(is.null(header)){
        lbl <- switch (tp,
                       stock = "Stock levels",
                       flow  = "Flows",
                       "Other"
                         )
      }  
      headerLine(lbl)
      if(is.null(footer)){
        a <- sprintf("History: Summary stock and flow data ('000), n=%1d",
                      nrow(e$s)
                    )
      }
      footerLine(footer, source = TRUE)
      k <- 0
    }
  }  
  par(mfrow=c(1,1))
  par(opar)
}

# Examples ---------------------------------------------------------------------

if(settings$runExamples && exists("model")){
  # Show stock levels in historic data
  # modelPlotEntities(model    = model,
  #                   mfrow    = c(3,3),
  #                   entities = e$en$stocks$id,
  #                   period   = c("H01", "M60")
  #                   )
  # Combine Naive and Lapsed
  l <- c("S00/01", setdiff(model$en$stocks$id, c("S00", "S01")))
  modelPlotEntities(model=model, entities = l, period = c("H01", "M98"))
  rm(l)
}

```

```{r Model - Plot flow grid}

modelPlotFlowGrid <- function(model                = NULL, 
                              data                 = NULL,
                              entities             = NULL,                      # NULL: All stocks
                              period               = NULL,                      # String with column names
                              showFlowShares       = NULL,                      # Show share of outflows, inflows
                              aggregateNaiveLapsed = TRUE,                      # Only if entities is 'stocks' or 'flows'
                              showInternalFlows    = TRUE,                      # Only if entities is 'stocks' or 'flows'
                              showTotals           = TRUE,                      # Show totals rows and columns
                              globalScaling        = FALSE,                     # Scale all graphs to global max
                              showMagnitude        = "shading",                 # 'none', 'shading'
                              entityLabels         = "name",                    # 'name', 'ID'
                              highlightModelTrace  = TRUE,
                              header               = NULL,
                              footer               = NULL, 
                              debug                = TRUE
                             )
{ 

  # Settings 
  
  gridSpacing <- 0.2                                                            # Hor/vert gaps between graphs
  yScale      <- 0.001                                                          # Value multiplier (e.g. for projected)
  yMaxBox     <- 0.85                                                           # Maximum y-axis, normalized
  lblSize     <- 0.7                                                            # Row/column labels 
  
  if(!(showFlowShares %in% c("inflow", "outflow"))) showFlowShares <-""
  if(showFlowShares!="") showTotals <- TRUE                                     # Always show totals if flow shares are display  

  # Data
  if(is.null(data) && is.environment(model)){
    d <- model$data
    stocks <- model$en$stocks
  } else
  if(!is.null(data) && is.null(model)){
    d <- data
    stocks <- e$en$stocks
  } else
  {
    warning("Model environment or data table required, not both!")
    return()
  }
  
  # Period
  nn <- names(d)[grep("^[H,M][0-9]{2}", names(d))]
  if(length(period)==2){
    nn <-nn[match(period[1],nn):match(period[-1],nn)]
  }else
  if(!is.null(period)){
    nn <- period
  }
  x0 <- as.integer(gsub("H","",nn[grep("^H",nn)]))                              # Timeline for historic data
  x1 <- as.integer(gsub("M","",nn[grep("^M",nn)]))                              # Timeline for future data
  x  <- c(x0-60, x1)                                                            # Unified timeline (H60=M0=0)
  
  # Entities (stocks)
  if(is.null(entities)){
    entities <- d[type=="stock", entity]
  }else  
  if(!all(entities %in% d[type=="stock", entity])){
    warning("'entities' should be stock IDs ('S00', 'S01',...)")
    return()
  }
  n <- length(entities)

  # Aggregate Naive and Lapsed
  if(aggregateNaiveLapsed){
    d2 <- copy(d)
    k <- which(d2$entity == "S00")
    v <- colSums(d2[entity %in% c("S00", "S01"),..nn])
    set(d2, i=k, j=nn, as.list(v))
    set(d2, i=k, j=1L, v="S00/01")
  
    for (j in 1:n) {
      l0 <- paste0("FS00_", entities[j])
      l1 <- paste0("FS01_", entities[j])
      v <- colSums(d[entity %in% c(l0, l1),..nn])
      k <- which(d2$entity == l0)
      set(d2, i=k, j=nn, as.list(v))
      set(d2, i=k, j=1L, v=paste0("FS00/01_", entities[j]))
    }  
    for (i in 1:n) {
      l0 <- paste0("F", entities[i],"_S00")
      l1 <- paste0("F", entities[i],"_S01")
      v <- colSums(d[entity %in% c(l0, l1),..nn])
      k <- which(d2$entity == l0)
      set(d2, i=k, j=nn, as.list(v))
      set(d2, i=k, j=1L, v=paste0("F", entities[i],"_S00/01"))
    }  
    
    l0 <- paste0("FS00/01_S00")
    l1 <- paste0("FS00/01_S01")
    v <- colSums(d[entity %in% c(l0, l1),..nn])
    k <- which(d2$entity == l0)
    set(d2, i=k, j=nn, as.list(v))
    set(d2, i=k, j=1L, v=paste0("FS00/01_S00/01"))
    
    d <- d2
    entities    <- c("S00/01", entities[!(entities %in% c("S00", "S01"))])
    n <- length(entities)
  }
  
  # Entity labels
  entityNames <- entities
  if(entityLabels=="name"){
    if(!is.null(model$en$stocks$short_name)){
      l <- model$en$stocks[match(entities, id), short_name]                     # Try to find short name in model entities
    }else{
      l <- e$en$stocks[match(entities, id), short_name]                         # If not found, try data entities
    }
    entityNames[!is.na(l)] <- l[!is.na(l)]                                      # If not found, use stock ID
    entityNames[entityNames %in% "S00/01"] <- "No Rx"                           # Naive/lapsed
  }  
  rowEntities <- entities
  colEntities <- entities
  rowEntityNames <- entityNames
  colEntityNames <- entityNames

  # Add totals rows and columns

  if(showTotals){
    m <- names(d)[grep("^[H,M][0-9]{2}", names(d))]
    for(i in 1:n){
      l <- paste0("F", rowEntities[i],"_", colEntities)
      y <- as.numeric(colSums(d[entity %in% l, ..m]))
      d <- rbind(d, append(list(sprintf("F%s_Stotal",entities[i]), "flow", i, NA), y))
    }
    for(j in 1:n){
      l <- paste0("F", rowEntities,"_", colEntities[j])
      y <- as.numeric(colSums(d[entity %in% l, ..m]))
      d <- rbind(d, append(list(sprintf("FStotal_%s",entities[j]), "flow", NA, j), y))
    }
    {
      l <- paste0("F", rowEntities,"_Stotal")
      y <- as.numeric(colSums(d[entity %in% l, ..m]))
      d <- rbind(d, append(list(sprintf("FStotal_Stotal"), "flow", NA, j), y))
    }  
    n <- n + 1
    colEntities    <- c("Stotal", entities)
    colEntityNames <- c("Total", entityNames)
    rowEntities    <- c(entities, "Stotal")
    rowEntityNames <- c(entityNames, "Total")
    entities       <- c("Stotal", entities)
    entityNames    <- c("Total", entityNames)
  }
  
  getData <- function(i, j, nn){                                                # Get single row of data
    isTotal <- rowEntities[i]=="Stotal" || colEntities[j]=="Stotal"
    l <- paste0("F", rowEntities[i],"_", colEntities[j])
    y <- d[match(l, entity), ..nn]
    if(nrow(y)==1) y <- as.numeric(y)
    
    if(showFlowShares=="outflow" && !isTotal){
      k <- which(colEntities == "Stotal")
      l <- paste0("F", rowEntities[i],"_", colEntities[k])
      y0 <- as.numeric(d[match(l, entity), ..nn])
      y <- y/y0
      y[!is.finite(y)] <- 0
    } else
    if(showFlowShares=="inflow" && !isTotal){
      k <- which(rowEntities == "Stotal")
      l <- paste0("F", rowEntities[k], "_", colEntities[j])
      y0 <- as.numeric(d[match(l, entity), ..nn])
      y <- y/y0
      y[!is.finite(y)] <- 0
    } else{
      y <- y * yScale
    }
        
    return(y)
  }

  # Y-axis and axis axis limits
  
  ymax      <- 0                                                                # Global max, excl totals
  ymean     <- 0                                                                # Global mean, excl totals
  ymaxTotal <- 0                                                                # Global maximum, totals
  yfinal    <- 0

  for (i in 1:n) {                                                              # Global totals for scaling
    for (j in 1:n) {
      isTotal <- rowEntities[i]=="Stotal" || colEntities[j]=="Stotal"
      y <- getData(i, j, nn)
      if(showInternalFlows || i!=j){
        if(isTotal){
            ymaxTotal  <- max(max(y, na.rm = TRUE), ymaxTotal)
        }else{
          yfinal <- yfinal + y[length(y)]
          ymax  <- max(max(y, na.rm = TRUE), ymax)
          ymean <- max(mean(y, na.rm = TRUE), ymean)
        }
      }
    }
  }
  
  # Plot
  
  opar <- par(no.readonly = TRUE)
  par(mfrow=c(n,n), mar=rep(gridSpacing,4), oma=c(4,5,7,3))
  
  ft <- 0
  for (i in 1:n) {
    for (j in 1:n) {
      isTotal <- rowEntities[i]=="Stotal" || colEntities[j]=="Stotal"
      y <- getData(i, j, nn)
      if(y[1] %in% 0.0) y[1] <- NA
      
      ymaxij  <- max(y, na.rm = TRUE)                                           # Max/mean of current plot
      k <- match(1,c(0,0,0,1)>0)
      ymeanij <- mean(y[k:length(y)], na.rm = TRUE)                             # Mean from first non zero value!
      if(globalScaling){
        yl  <- c(0, if(isTotal) c(0, ymaxTotal) else c(0, ymax))
      } else{
        yl <- c(0, ymaxij)
      }
      if(yl[2]==0.0) yl <- c(0,1)

      plot(NA, type='l', ann=FALSE, xaxt="n", yaxt="n", bty="n", 
           ylim=yl/yMaxBox, xlim=range(x))
      
      if(showInternalFlows || i!=j){
        
        if(showMagnitude=="shading" && !isTotal){
          l <- sqrt(min(1, (1.0-0.35*ymeanij/ymean)))              # Shading curve
          rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4],
               col = rgb(l, l, l), border = NA)
        }

        # Box, separation line, scale labels
        
        if(isTotal){
          box(col="gray30")
          rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4],
               col = rgb(0.95,0.95,1.0), border = NA)
        }else{
          box(col="gray70")
        }
        f <- ifelse(showFlowShares!="" && !isTotal, "%1.3f", "%1.1f")           # Number format for lables
        text(x=grconvertX(0.98, "npc"), y=grconvertY(0.97,"npc"),               # Axis limit (top right)
             labels = sprintf(f, yl[2]), cex=0.7, col="gray50", adj=c(1,1))
        
        text(x=grconvertX(0.02, "npc"), y=grconvertY(0.97,"npc"),               # Mean value (top left)
             labels = sprintf(f, ymeanij), cex=0.7, col="gray50", adj=c(0,1))
        
        lines(x=grconvertX(c(0.7,1.0),"npc"), y=rep(yl[2],2),                   # Max y line (top right)
              lwd=1, col="gray80")
        
        if(length(x0)>0){                                                       # History/simulation separator
          lines(x=c(0,0), y=yl, col=rgb(1.0,0.6,0.6), lwd=1)
        } 

        if(highlightModelTrace){                                                # Make model line stand out
          col = c("gray60", "blue")
          lwd = c(1, 2)
        }else{
          col = c("blue", "blue")
          lwd = c(1, 1)
        }

        if(length(x0)>0){                                                       # Historical data
          k <- 1:length(x0)
          lines(x[k], y[k], col=col[1], lwd=lwd[1])
        }
        if(length(x1)>0){                                                       # Model data
          k <- 1:length(x1) + length(x0)
          lines(x[k], y[k], col=col[2], lwd=lwd[2])
        }
      }else{
        box(col="gray90")
      }
    }  
  }
  
  # Chart labels
  
  par(mfrow=c(1,1), mar=c(0,0,0,0))
  par(oma=c(2.8 ,2.2 ,4.7 ,2.1))

  l <- substr(rowEntityNames, 1, 100/n)                                         # Row names
  box(lty=0)                                                                    # needed to show text fields
  text(x=grconvertX(0, "nfc"), 
       y=grconvertY(seq(1/n/2, 1-1/n/2, length.out=n), "nfc"),
       labels = rev(l), xpd=TRUE, srt=90, adj=c(0.5,1), cex=lblSize)
  
  par(oma=c(2.8, 3.2, 3.7, 2.1))
  
  l <- substr(colEntityNames, 1, 100/n)                                         # Column names
  box(lty=0)                                                                    # needed to show text fields
  text(x=grconvertX(seq(1/n/2, 1-1/n/2, length.out=n), "nfc"), 
       y=grconvertY(1, "nfc"),
       labels = l, xpd=TRUE, srt=0, adj=c(0.5,1), cex=lblSize)

  par(oma=c(2.8, 2.2, 3.7, 2.1))
  box(lty=0)                                                                    # needed to show text fields
  text(x=grconvertX(0.005, "nfc"), y=grconvertY(0.995, "nfc"),
       labels = "<- from", xpd=TRUE, srt=90, adj=c(1,0.5), cex=0.6)
  text(x=grconvertX(0.02, "nfc"), y=grconvertY(0.993, "nfc"),
       labels = "to ->", xpd=TRUE, srt=0, adj=c(0,0.5), cex=0.6)

  par(mfrow=c(1,1))
  if(is.null(header)){
    if(showFlowShares!="")
      header <- paste0("Share of patient ", showFlowShares,"s")
    else{
      header <- "Patient flows"
    }  
  }
  headerLine(header)
  
  if(is.null(footer)){
    footer <- paste0("Patient flows in '000/month. ")
    footer <- paste0(footer, paste(nn[1], nn[length(nn)], sep="-"), ". ")
    footer <- paste0(footer, "Top left: mean from first non-zero value, top right: Y-axis limit. ")
    if(!showFlowShares!=""){
      footer <- paste0(footer, sprintf("Total flows in final months: %1.1fk", yfinal))
    }
  }
  footerLine(footer, source = TRUE)

  par(opar)
}

# Examples ---------------------------------------------------------------------

if(settings$runExamples && exists("model")){
  # modelPlotFlowGrid(model          = model,
  #                   period         = c("H01", "M60"),
  #                   showFlowShares = FALSE
  #                   )

  modelPlotFlowGrid(model          = model,
                    period         = c("H01", "M60"),
                    showFlowShares = "inflow"
                    )
}

```

```{r Model - Plot stock details}

modelPlotStockDetails <- function(model         = NULL,
                                  data          = NULL,
                                  stockId       = NULL,
                                  period        = c("M97", "M98"),
                                  maxFlows      = 5,                            # Max number of flows to show
                                  labels        = "mean",                       # "max", "mean", "last" 
                                  globalScaling = FALSE,
                                  showDeathRate = TRUE,
                                  showStockInfo = TRUE,
                                  header        = NULL,
                                  footer        = NULL
                                 )

{
  
  # Data
  if(is.null(data) && is.environment(model)){
    d <- model$data
    stocks <- model$en$stocks
  } else
  if(!is.null(data) && is.null(model)){
    d <- data
    stocks <- e$en$stocks
  } else
  {
    warning("Model environment or data table required, not both!")
    return()
  }
  
  mar         <- c(1.0,1.0,1.5,1.0) * 0.04
  showFrames  <- FALSE
  yScale      <- 0.001
  yMaxBox     <- 0.85
  arrowScale  <- 0.05                                                           # Relative width of arrows

  # Period
  nn <- names(d)[grep("^[H,M][0-9]{2}", names(d))]
  if(length(period)==2){
    nn <-nn[match(period[1],nn):match(period[-1],nn)]
  }else
  if(!is.null(period)){
    nn <- period
  }
  x0 <- as.integer(gsub("H","",nn[grep("^H",nn)])) - 60
  x1 <- as.integer(gsub("M","",nn[grep("^M",nn)]))
  x  <- c(x0, x1)


  # Entities (stock)
  if(is.null(stockId)){
    stockId   <- d[type=="stock", entity][3]
    stockName <- e$en$stocks[match(stockId, id),display_name]
  }

  # Viewports ------------------------------------------------------------------

  grid.newpage()
  i <- min((1-mar[2]-mar[4]), (1-mar[1]-mar[3]))                                # Inner VP (apply margins)
  vpo <- viewport(x=unit(mar[2]+i/2, "npc"),
                  y= unit(mar[1]+i/2, "npc"), 
                  width  = unit(i, "npc"), 
                  height = unit(i, "npc"),
                  name = "outerVP"
                 )
  pushViewport(vpo)

  vpi <- viewport(x=unit(0.5, "npc"),
                  y=unit(0.5-0.02, "npc"), 
                  width  = unit(1.0, "npc"), 
                  height = unit(1-0.1, "npc"),
                  name = "innerVP"
                 )
  pushViewport(vpi)
    
  if(showFrames){
    grid.rect(0, 0, 1, 1, vjust = 0, hjust = 0,  
              gp=gpar(col="grey80", fill=NA)
             )
  }  

  # Stock ----------------------------------------------------------------------
  
  y0 <- as.numeric(d[entity %in% stockId, nn[grep("^H",nn)], with=FALSE])*yScale  # History
  y1 <- as.numeric(d[entity %in% stockId, nn[grep("^M",nn)], with=FALSE])*yScale  # Model output

  ymax  <- max(c(y0, y1), na.rm = TRUE)
  ymean <- mean(c(y0, y1), na.rm = TRUE)
  
  if(sum(abs(c(y0,y1)))==0){
    warning("Stock level = 0!")
    return()
  }

  vp <- viewport(x      = unit(0.50, "npc"),
                 y      = unit(0.50, "npc"), 
                 width  = unit(0.30, "npc"), 
                 height = unit(0.27, "npc"),
                 name   = "stockVP"
                )
  pushViewport(vp)

  grid.text(stockId, 0.05,0.96, hjust=0, vjust=1,
            gp=gpar(font=2, cex=1.0))

  if(length(x0)>0){
    y   <- y0/ymax*yMaxBox
    grid.polygon(x = (c(x0[1],x0[1],x0,x0[length(x0)])-x[1])/(x[length(x)]-x[1]), # Historic stock values (shaded area)
                 y = c(0,y[1],y,0),
                 gp=gpar(fill=rgb(0.8,0.8,0.8), col=NA))
  }
  
  if(length(x1)>0){
    y   <- y1/ymax*yMaxBox
    grid.polygon(x = (c(x1[1],x1[1],x1,x1[length(x1)])-x[1])/(x[length(x)]-x[1]), # Future stock values (shaded area)
                 y = c(0,y[1],y,0), 
                 gp=gpar(fill=rgb(0.7,0.7,1.0), col=NA))
  }
  
  if(length(x1)>1 && 0 %in% x1){
    k <- match(0, x1)
    xl <- -x[1]/(x[length(x)]-x[1])
    grid.segments(xl, 0, xl, y1[k]/ymax*yMaxBox, gp=gpar(col=rgb(1,0,0)))
  }
  
  l <- switch(labels, 
    "max"  = sprintf("Max: %1.1fk", ymax),
    "mean" = sprintf("Mean: %1.1fk", ymean),
    "last" = sprintf("Last: %1.1fk", y1[length(y1)]),
  )
  
  grid.text(l, x=0.95,y=0.96, hjust=1, vjust=1,
            gp=gpar(font=1, cex=0.7, col="gray50"))
  
  grid.text(c(nn[1], nn[length(nn)]),
            x=c(0,1) ,y=-0.05, hjust=0.5, vjust=1,
            gp=gpar(cex=0.7, col="gray50"))
  
  grid.rect(0.50,0.50,1.0,1.0, 
            gp=gpar(lwd=2, col="gray70", fill=NA)
            )
  
  popViewport()

  # Inflows values -------------------------------------------------------------

  ymaxTotal <- 0
  
  i <-  d[type=="flow" & grepl(paste0("_",stockId), d[, entity]), entity]
  fi <- d[entity %in% i,]
  fi <- topn(fi,maxFlows)
  n <- nrow(fi)
  for(i in 1:n){
    y0 <- as.numeric(fi[i, nn[grep("^H",nn)], with=FALSE])*yScale
    y1 <- as.numeric(fi[i, nn[grep("^M",nn)], with=FALSE])*yScale
    ymaxTotal <- max(ymaxTotal, max(y0, y1, na.rm = TRUE))
  }

  # Outflows values ------------------------------------------------------------

  i <-  d[type=="flow" & grepl(paste0("F",stockId,"_"), d[, entity]), entity]
  fo <- d[entity %in% i,]
  fo <- topn(fo,maxFlows)
  n <- nrow(fo)
  for(i in 1:n){
    y0 <- as.numeric(fo[i, nn[grep("^H",nn)], with=FALSE])*yScale
    y1 <- as.numeric(fo[i, nn[grep("^M",nn)], with=FALSE])*yScale
    ymaxTotal <- max(ymaxTotal, max(y0, y1, na.rm = TRUE))
  }

  # Graphic elements for flows -------------------------------------------------

  flowPlot <- function(y0, y1, px, py, w, h, lbl){
    
    vp <- viewport(x      = unit(px, "npc"),
                   y      = unit(py, "npc"), 
                   width  = unit(w, "npc"), 
                   height = unit(h*0.9, "npc"),
                   name   = "stockVP"
                  )
    pushViewport(vp)
    grid.rect(gp=gpar(col="gray50"))
    
    if(globalScaling){
      yl <- ymaxTotal
    } else
    {
      yl <- max(y0, y1, na.rm = TRUE)
    }
    
    grid.segments(0.75, yMaxBox, 1.0, yMaxBox,                                  # Y-limit marker line
                  gp = gpar(col="gray80"))
    grid.text(sprintf("%1.1fk", yl), 0.96, 0.96, hjust=1, vjust=1,              # Y-limit label
              gp=gpar(font=1, cex=0.6, col="gray50"))
    
    if(length(x0>0)){
      grid.segments((x0[1:(length(x0)-1)]-x[1])/(x[length(x)]-x[1]),            # Historicdata
                     y0[1:(length(y0)-1)] / yl * yMaxBox,
                    (x0[2:(length(x0)-0)]-x[1])/(x[length(x)]-x[1]),
                     y0[2:(length(y0)-0)] / yl * yMaxBox,
                    gp = gpar(col="gray50"))
    }
    if(length(x1)>0){
      grid.segments((x1[1:(length(x1)-1)]-x[1])/(x[length(x)]-x[1]),            # Future data
                     y1[1:(length(y1)-1)] / yl * yMaxBox,
                    (x1[2:(length(x1)-0)]-x[1])/(x[length(x)]-x[1]),
                     y1[2:(length(y1)-0)] / yl * yMaxBox,
                    gp = gpar(col=rgb(0,0,1), lwd=2))
    }
    grid.text(lbl, 0.04, 0.96, hjust=0, vjust=1,
              gp=gpar(font=2, cex=0.6))

    popViewport()
  }  

  flowArrow <- function(x,y,l=0.065,w=0.02,r=0){
    aw <- max(w*1.6, 0.01)
    xc <- c(0.00,0.00,l,l,l+0.03,l,l, 0.00,0.00)
    yc <- c(0.00,w,w,aw,0.00,-aw,-w,-w,0.00)/2
    if(r %in% c(1, 3)){
      j <- xc
      xc <- yc
      yc <- j
    }
    if(r == 2) xc <- -xc
    if(r == 3) yc <- -yc
    grid.polygon(x+xc,y+yc, gp=gpar(lwd=2, col=NA, fill="gray80"))
  }
    
  # Plot inflows ---------------------------------------------------------------
  
  yp <- seq(1-1/n/2, 1/n/2, length.out=n)
  wp <- 0.15
  ym <- 0
  wa <- 0

  for(i in 1:n){
    y0 <- as.numeric(fi[i, nn[grep("^H",nn)], with=FALSE])*yScale
    y1 <- as.numeric(fi[i, nn[grep("^M",nn)], with=FALSE])*yScale
    flowPlot(y0, y1, wp/2, yp[i], wp, 1/n, fi$entity[i])
    ym[i] <- mean(c(y0,y1))
    wa[i] <- max(arrowScale*ym[i]/ymaxTotal, 0.00)
  }
  for(i in 1:n){
    grid.rect(wp, yp[i], 0.10, wa[i],
       hjust=0, gp=gpar(col=NA, fill="gray80"))
    grid.text(sprintf("%1.2f",ym[i]), x=wp+0.01, yp[i]+0.01+wa[i],
       hjust=0, gp=gpar(col="gray50", cex=0.6))
    if(i<=n/2){
      j <- cumsum(wa[1:i])
    } else {
      j <- cumsum(wa[n:i])
    }                
    grid.rect(wp+0.10, yp[i]+wa[i]/2, j, yp[i]-0.5+j/2,
         hjust=1, vjust=1, gp=gpar(lwd=2, col=NA, fill="gray80"))
  }
  flowArrow(wp+0.075+0.02,0.50,0.07,sum(wa))
  grid.text(sprintf("%1.2f",sum(ym)), x=0.26, 0.50+0.02+sum(wa)/2,           # Mean values on total arrow
     hjust=0, gp=gpar(col="gray50", cex=0.6))
  
  # Plot outflows --------------------------------------------------------------
  
  ym <- 0
  wa <- 0
  for(i in 1:n){
    y0 <- as.numeric(fo[i, nn[grep("^H",nn)], with=FALSE])*yScale
    y1 <- as.numeric(fo[i, nn[grep("^M",nn)], with=FALSE])*yScale
    flowPlot(y0, y1, 1-wp/2, yp[i], wp, 1/n, fo$entity[i])
    # wa[i] <- max(0.04*y1[length(y1)]/ymaxTotal, 0.00)
    ym[i] <- mean(c(y0,y1))
    wa[i] <- max(arrowScale*ym[i]/ymaxTotal, 0.00)
  }
  for(i in 1:n){
    if(i<=n/2){
      j <- cumsum(wa[1:i])
    } else {
      j <- cumsum(wa[n:i])
    }                
    grid.rect(wp+0.59, yp[i]+wa[i]/2, j, yp[i]-0.5+j/2,
         hjust=0, vjust=1, gp=gpar(lwd=2, col=NA, fill="gray80"))
    flowArrow(1-wp-0.11 ,yp[i],0.07,wa[i])
    grid.text(sprintf("%1.2f",ym[i]), x=wp+0.65+0.01, yp[i]+0.02+wa[i],         # Mean values on outflow arrows
       hjust=0, gp=gpar(col="gray50", cex=0.6))

  }
  grid.rect(0.655, 0.50, 0.09, sum(wa),
       hjust=0, gp=gpar(lwd=2, col=NA, fill="gray80"))
  grid.text(sprintf("%1.2f",sum(ym)), x=wp+0.51, 0.50+0.02+sum(wa)/2,           # Mean values on total arrow
     hjust=0, gp=gpar(col="gray50", cex=0.6))
  
  # Death rate -----------------------------------------------------------------
  
  if(showDeathRate && !is.null(model$summary$mortality)){
    dr <- ymean * with(model$summary, mortality, match(stockId,entity))
    flowArrow(0.5, 0.36, l=0.09, w=0.03, r=3)
    grid.text(sprintf("%1.2f/yr", dr), x=0.50, 0.22,           # Mean values on total arrow
     hjust=0.5, gp=gpar(col="gray50", cex=0.7))
  }


  # Stock into -----------------------------------------------------------------

  if(showStockInfo && !is.null(model$summary)){
    a <- model$summary
    l <- sprintf("Mean age: %1.1f",a$age[match(stockId, a$entity)])
    
    l[2] <- sprintf("Male/fem : %1.0f/%1.0f", 
                    a$male[match(stockId, a$entity)] *100, 
                    a$female[match(stockId, a$entity)] *100)
    l[3] <- sprintf("Mortality  : %1.2f%%", 
                    a$mortality[match(stockId, a$entity)] *100)
    yp <- 0.34 - seq_along(l) *0.03
    grid.text(l, x=0.35, y=yp, hjust=0, gp=gpar(col="gray50", cex=0.8))
  }
  
  # Header and footer ----------------------------------------------------------
  
  upViewport()

  if(is.null(header)){
    header <- paste(stockId, with(e$en$stocks, display_name[match(stockId,id)]),
                    sep=" - ")
  }
  if(header!=""){
    grid.text(
      label = header,
      x = 0, y= 1,
      hjust = 0, vjust = 1,
      gp = gpar(col="black", fill=NA, cex=1.4, font=2)
    )
  }

  if(is.null(footer)) footer <- "Footnote"

  l <- 'footer'

  grid.text(
    label = l,
    x = 0, y=0, hjust = 0, vjust = 0,
    gp = gpar(col="grey60", fill=NA, cex=0.8),
  )
  
  return(NULL)
}

# Examples ---------------------------------------------------------------------

if(settings$runExamples && exists("model")){

  modelPlotStockDetails(model=model, 
                        stockId ="S10", 
                        period  = c("M97", "M98")
                        )

}
```

```{r Model - Model update}

modelUpdate <-function(model,                                                   # Model environment
                       lifetimes       = NULL,                                  # Default: Use lifetimes in model summary
                       mortality       = NULL, 
                       extflows        = NULL,
                       switchMatrix    = NULL,                                  # Default: Use share of outflows in model summary
                       simSteps        = 98,                                  # Default: Periods in model data table
                       subSteps        = 1,                                     # Sub-steps in each period 
                       levers          = NULL,                                  # Default: none
                       applyLevers     = TRUE, 
                       showLevers      = FALSE,                                 # Generate summary graphic of levers
                       updateModelData = TRUE,
                       debug           = TRUE
                      )
{
 
  # Settings
  
  yScale <- 0.001
   
  # Set initial values and parameters ------------------------------------------
  
  # Entities 

  sid <- model$en$stocks$id                                                     # Master list of stocks
  
  # Timeline 

  if(is.null(simSteps)){
    simSteps <- sum(grepl("M[0-9]{2}", names(model$data)))
  }
  if(simSteps>99){
    warning("Error: Maximum simulation time 99 months!")                        # Todo: Change to >99 (limited by M00 format)
    return()
  }
  n <- names(model$data)
  x <- as.integer(gsub("M", "", setdiff(n[grepl("^M[0-9]", n)],"M00")))
  if(!all(x==sort(x))){
    warning("Timeline in model data not sequential!", call. = FALSE)
    return(NULL)
  }
  simSteps <- length(x)                                                         # Todo: No direct input of sim Steps ok?
   
  # Stock lifetimes 
  
  if(is.null(lifetimes)){                                                       # Use summary lifetimes if not provided
    lifetimes <- model$summary$lifetime
    if(debug){ 
      warning("Stock lifetimes not provided. Using values from model summary!", 
              call. = FALSE)
    }  
  }
  
  # Mortality rates
  
  if(is.null(mortality)){                                                       # Use summary mortality rates if not provided
    mortality <- model$summary$mortality
    if(debug){ 
      warning("Mortality rates not provided. Using values from model summary!", 
              call. = FALSE)
    }  
  }
  model$mo <- mortality
  
  # Switch matrix
  
  if(is.null(switchMatrix)){
    
    warning("Switch matrix not provided. Using share or outflows from model summary!", 
            call. = FALSE)
    n <- grep("share of outflow", names(model$summary))
    switchMatrix           <- as.matrix(model$summary[,..n])
    rownames(switchMatrix) <- model$summary$entity
    colnames(switchMatrix) <- model$summary$entity
    
  }else
  if(is.data.table(switchMatrix)){
    switchMatrix <- as.matrix(switchMatrix)
    warning("Switch matrix provided as data.table. Converted to matrix!",
            call. = FALSE)
  }
  
  if(!all(rownames(switchMatrix) == sid) || !all(colnames(switchMatrix) == sid)){
    warning("Row or column names of switch matrix not consitent with stock IDs!",
            call. = FALSE)
    return(NULL)
  }
  
  model$sm <- switchMatrix

  # Apply levers ---------------------------------------------------------------
  
  if(!is.null(levers)){
    
    if(!is.list(levers)){
      warning("Levers need to be supplied in list format!", call. = FALSE)
      return(NULL)
    } 
    if(!all(grepl("^FS[0-9]{2}_S[0-9]{2}$", trimws(names(levers))))){
      warning("Lever entity name formats not recognised!", call. = TRUE)
      return(NULL)
    }
  
    # Convert levers to time series
    
    leverToTimeSeries <- function(x, y, xout = 0:60, eps = 0.0001, ties=1){
      if(!all(x == sort(x))){
        warning("Time sequence provided not sequential!", call. = FALSE)
        return(NULL)
      }
      if(length(x)!=length(y)){
        warning("Time and value sequence length not equal!", call. = FALSE)
        return(NULL)
      }
      if(length(x)==1){
        return(list(x=xout,y=rep(y, length(xout))))
      }
      if(ties==1){                                                              # Break ties by moving x-values to right
        i <- 1
        while(i<length(x)-1){
          if(x[i]==x[i+1]){
             x[i] <- x[i] - eps
             i <- 1
          } else{
            i <- i + 1
          }
        }
      }else 
      if(ties==2){                                                              # Break ties by moving x-values to left
        i <- length(x)
        while(i>1){
          if(x[i]==x[i-1]){
             x[i] <- x[i] + eps
             i <- length(x)
          } else{
            i <- i - 1
          }
        }
      }
      return(approx(x=x, y=y, xout=xout, rule = 2))
    }

    # Convert levers to time series table 
    
    nn <- trimws(toupper(names(levers)))                                        # Lever summary
    le <- data.frame(entity = character(0L),
                     type   = character(0L),
                     value  = matrix(0, nrow=0, ncol=simSteps)
                    )
    names(le)[3:ncol(le)] <- sprintf("M%02d", x)

    if(showLevers){
      opar <- par(no.readonly = TRUE)
      par(mfrow=c(3, 3))
    }
    
    n <- 1
    for(i in 1:length(levers)){
      l  <- levers[[i]]
      for(tp in c("mult", "add", "set")){                                              # Todo: add func, const etc..
        if(is.null(l[[tp]])) next

        # Lever name, type, from, to stock
        le[n,"entity"]   <- names(levers)[i]
        le[n, "type"]    <- tp
        # Values
        a  <- leverToTimeSeries(l$t, l[[tp]], xout=x, ties=2)
        if(!is.null(a) && length(a$y)==simSteps){
          le[n, 1:simSteps + 2] <- a$y
        }  
        
        if(showLevers){
          yl <- c(0, max(a$y, na.rm = TRUE)) *1.2
          if(yl[2]==0) yl <- c(0,1)
          plot(a$x, a$y, type = 'l', col = 'blue', las = 1,
               ylim = yl,
               xlab = "", ylab = "", 
               main = paste(le[n,"entity"], "-", le[n,"type"]))
        }
        k <- match(le$entity[n], model$data$entity)
        if(is.na(k)){
          warning(sprintf("Lever name %1s not found in model data!", le[n,"entity"]),
                  call. = FALSE)
          return(NULL)
        }
        n <- n+1
      }
    }  
    if(showLevers){
      par(opar)
    }
  } else{
    le <- NULL
  }
  model$le <- le
  
  # Set up simulation ----------------------------------------------------------

  s <- model$data[type=="stock", M00]                                           # Initial stock values
  s0 <- sum(s)                                                                  # Total stock value for integrity checking

  # Time varying switch matrix 
  
  sm <- array(NA, 
              dim      = c(nrow(switchMatrix), ncol(switchMatrix), simSteps),
              dimnames = list(rownames(switchMatrix),
                              colnames(switchMatrix),
                              sprintf("M%02d",x))
              )                                                                 # Somewhat obese...
  for(i in 1:simSteps){
    sm[,,i] <- switchMatrix
  }

  # Apply levers
  
  if(applyLevers && !is.null(le) && nrow(le)>0){
    
    for(n in 1:nrow(le)){
      
      nn <- paste0("'", le[n, "entity"], " ", le[n,"type"],"'")
      print(paste("Applying lever", nn), quote=FALSE)
      a  <- as.numeric(le[n, sprintf("M%02d", x)])
      k1 <- match(substr(le[n, "entity"], 2, 4), dimnames(sm)[[1]])
      k2 <- match(substr(le[n, "entity"], 6, 8), dimnames(sm)[[2]])
      if(is.na(k1) || is.na(k2)){
        warning(paste("Lever", nn, 
                  "not consistent with switch matrix entities!"), call. = FALSE)
        break()
      }
      if(any(!is.finite(a) & is.na(a))){
          warning(paste("Lever", nn, "contains invalid numbers!"), call. = FALSE)
      }  
      if(le[n,"type"]=="mult"){
        if(any(a %in% 0)){
          warning(paste("Lever ", nn, "contains zeros!"), call. = FALSE)
        }
        sm[k1, k2, ] <- sm[k1, k2, ] * a
      } else
      if(le[n,"type"]=="add"){
        sm[k1, k2, ] <- sm[k1, k2, ] + a
      } else
        if(le[n,"type"]=="set"){
          sm[k1, k2, ] <- a
      }
    }  
  }

  # Re-normalize switch matrix (force all rowSums==1)
  
  for(i in 1:simSteps){
    sm[,,i] <- sm[,,i]/rowSums(sm[,,i])
  }
  model$sm <- sm
  
  # Simulation -----------------------------------------------------------------
  
  mo <- (1+mortality)^(1/12)-1                                                  # Monthly mortality for use in simulation
  if(is.null(extflows)){                                                        # Todo: allow for time varying incidence
    fi <- 0
  } else{
    fi <- extflows
  }
  
  for(i in 1:simSteps){

    lt <- lifetimes 
    f  <- rep(0, length(s))

    for(j in 1:subSteps){                                                       # Runge Kutta integrator (RK4)
      
      f1 <- sm[,,i] * (s/lt)/subSteps
      k1 <- colSums(f1) - rowSums(f1) + (fi-s*mo)/subSteps 

      f2 <- sm[,,i] * ((s+k1/2)/lt)/subSteps
      k2 <- colSums(f2) - rowSums(f2) + (fi-(s+k1/2)*mo)/subSteps

      f3 <- sm[,,i] * ((s+k2/2)/lt)/subSteps
      k3 <- colSums(f3) - rowSums(f3) + (fi - (s+k2/2)*mo)/subSteps

      f4 <- sm[,,i] * ((s+k3)/lt)/subSteps
      k4 <- colSums(f4) - rowSums(f4) + (fi - (s+k3)*mo)/subSteps

      s  <- s + 1/6 * (k1+2*k2+2*k3+k4)
      f <-  f + 1/6 * (f1+2*f2+2*f3+f4)
    }

    if(updateModelData){                                                        # Update by reference. Input table changed!
      model$data[type=="stock",sprintf("M%02d",i):= s]
      model$data[type=="flow",sprintf("M%02d",i):= as.vector(t(f))]
    }
  }
  
  # Stock totals ---------------------------------------------------------------
  
  s1 <- sum(s, na.rm = TRUE)
  
  if(abs(s1/s0-1)>1e-4){
    l <- sprintf("%1.2fx intial value, change %1.2f%% pa", 
                 s1/s0, ((s1/s0)^(1/simSteps*12)-1)*100)
    warning(paste0("Stock level not conserved! (", l,")"), call. = FALSE)
  }
  if(debug) print(paste("Final stock total:", l), quote=FALSE)
    
  en <- setdiff(sid, c("S00", "S01"))

  m  <- names(model$data)[grep("^[H][0-9]{2}", names(model$data))]
  x0 <- as.integer(gsub("H","", m))                                           # Timeline for historic data
  x0 <- x0-max(x0)
  y0total <- as.numeric(colSums(model$data[type=="stock",..m]))
  y0rx <- as.numeric(colSums(model$data[type %in% "stock" & entity %in% en,..m]))

  m  <- names(model$data)[grep("^[M][0-9]{2}", names(model$data))]
  x1 <- as.integer(gsub("M","", m))                                           # Timeline for simulation data
  y1total <- as.numeric(colSums(model$data[type=="stock",..m]))
  y1rx <- as.numeric(colSums(model$data[type %in% "stock" & entity %in% en,..m]))
  model$info$totals <- list(x0=x0, x1=x1, 
                            y0total=y0total, y1total=y1total, 
                            y0rx=y0rx, y1rx=y1rx)

  if(debug){
      
    opar <- par(no.readonly = TRUE)
    par(mar=c(4,6,3,2), oma=c(2,0,2,0))
    yl = c(0, max(y0total, y0rx, y1total, y1rx) * yScale)
    plot(NA, type="l", ylim=yl, lwd=2, col="blue", las=1, ylab="", xlab="", 
         xl = range(c(x0,x1)))
    abline(v=0, col="gray50")
    lines(x=x0, y=y0total*yScale, lwd=2, col="blue")
    lines(x=x1, y=y1total*yScale, lwd=2, col="blue")
    lines(x=x0, y=y0rx*yScale, lwd=2, col="red")
    lines(x=x1, y=y1rx*yScale, lwd=2, col="red")
    l <- sprintf("All patients: %+1.2f%% pa",
                 ((1+coefficients(lm(y0total~x0))[2]/mean(y0total))^12-1)*100)
    annotation(l, 0.05, 0.12, col="blue")
    l <- sprintf("All patients: %+1.2f%% pa",
                 ((1+coefficients(lm(y1total~x1))[2]/mean(y1total))^12-1)*100)
    annotation(l, 0.55, 0.12, col="blue")
    l <- sprintf("Rx patients: %+1.2f%% pa",
                 ((1+coefficients(lm(y0rx~x0))[2]/mean(y0rx))^12-1)*100)
    annotation(l, 0.05, 0.08, col="red")
    l <- sprintf("Rx patients: %+1.2f%% pa",
                 ((1+coefficients(lm(y1rx~x1))[2]/mean(y1rx))^12-1)*100)
    annotation(l, 0.55, 0.08, col="red")
    headerLine("Total population and Rx population")
    footerLine("Projected patients ['000]. Rx population: Exlcuding S00 and S01", 
               source = TRUE)
    par(opar)
  }

# Add / update metadata ------------------------------------------------------
  
  if(is.null(model$info)) model$info <- list()
  model$info$lastSimTime <- Sys.time()
  
  return(model)
}

# Examples ---------------------------------------------------------------------

if(settings$runExamples && exists("model")){
  
  levers <- list()
  levers$`FS00_S02` <- list(t    = c(  0,  10,  10),
                            mult  =c(  1,  1, 2.0)
                            )
  levers$`FS01_S02` <- list(t    = c(  0,  10,  10),
                            mult  =c(  1,  1, 2.0)
                            )

  # incidence <- c(0,0,rep(10000, nrow(model$en$stocks)-2))
  incidence <- 0
  
  m <- modelUpdate(model,
                   levers       = levers,
                   extflows     = incidence,
                   applyLevers  = TRUE,
                   showLevers   = FALSE, 
                   debug        = TRUE,
                   )
  
  nn <- model$summary$entity
  
  # modelPlotEntities(model,
  #                   mfrow = c(4,3),
  #                   entities = nn,
  #                   header = "Stock levels - Levers not applied")

  modelPlotFlowGrid(model          = model,
                    showFlowShares = "outflow"
                    )

  # modelPlotFlowGrid(model)

}

```

```{r Model - Scenarios}

# Create momentum base case scenario


# {
#   f2 <- function(m){list(t    = c(0,  50,  55,  60, 70, 80, 85, 90),
#                          add = c(0,    0,  0.15,  0.2,  0.3, 0.6, 0.8,  0.8)  * m)}
#   F10Launch <- list(
# 
#      # to S10
#     `FS00_S10` = f2(0.00),
#     `FS01_S10` = f2(0.03),
#     `FS02_S10` = f2(0.018),
#     `FS03_S10` = f2(0.01),
#     `FS04_S10` = f2(0.01),
#     `FS05_S10` = f2(0.05),
#     `FS06_S10` = f2(0.005),
#     `FS07_S10` = f2(0.01),
#     `FS08_S10` = f2(0.025),
#     `FS10_S10` = f2(0)
# 
#   )
# }


{
  f2 <- function(m){list(t    = c(0,  50,  55,  60, 70, 80, 85, 90),
                         add = c(0,    0,  0.08,  0.1,  0.15, 0.3, 0.4,  0.4) * m * 4)}
  F10Launch <- list(

     # to S10
    `FS00_S10` = f2(0.00),
    `FS01_S10` = f2(0.01),
    `FS02_S10` = f2(0.054),
    `FS03_S10` = f2(0.01),
    `FS04_S10` = f2(0.01),
    `FS05_S10` = f2(0.1),
    `FS06_S10` = f2(0.005),
    `FS07_S10` = f2(0.01),
    `FS08_S10` = f2(0.025),
    `FS10_S10` = f2(0)

  )
}




{
  f1 <- function(m){list(t    = c(0,20,35,50), 
                         mult = 1+c(0.0, 0.50,0.85,1.0) * m)}
  baseCase <- list(
      
     # to S08 - GLP1 Injectable
    `FS00_S08` = f1(0.5*0.5),
    `FS01_S08` = f1(2*0.5),
    `FS02_S08` = f1(0.2*0.5),
    `FS03_S08` = f1(1.0*0.5),
    `FS04_S08` = f1(1.0*0.5),
    `FS05_S08` = f1(1.2*0.5),
    `FS06_S08` = f1(0.8*0.5),
    `FS07_S08` = f1(1.5*0.5),
  
     # to S07 - GLP1 Oral
    `FS00_S07` = f1(1.8*3),
    `FS01_S07` = f1(15*3),
    `FS02_S07` = f1(1.5*3),
    `FS03_S07` = f1(1.5*3),
    `FS04_S07` = f1(1.8*3),
    `FS05_S07` = f1(3*3),
    `FS06_S07` = f1(1.0*3),
    `FS07_S07` = f1(0.3*3),
    `FS08_S07` = f1(1.4*3),
  
     # to S06 - Insulin
    `FS00_S06` = f1(0.0),
    `FS01_S06` = f1(0.0),
    `FS02_S06` = f1(0.0),
    `FS03_S06` = f1(0.0),
    `FS04_S06` = f1(0.0),
    `FS05_S06` = f1(0.0),
    `FS06_S06` = f1(0.0),
    `FS07_S06` = f1(0.2),
    `FS08_S06` = f1(-0.1),
  
     # to S05 - SGLT2
    `FS00_S05` = f1(0.6),
    `FS01_S05` = f1(0.6),
    `FS02_S05` = f1(1.0),
    `FS03_S05` = f1(0.6),
    `FS04_S05` = f1(0.6),
    `FS05_S05` = f1(0.3),
    `FS06_S05` = f1(0.3),
    `FS07_S05` = f1(0.1),
    `FS08_S05` = f1(0.0),
    
     # to S04 - DPP4
    `FS00_S04` = f1(-0.2),
    `FS01_S04` = f1(-0.2),
    `FS02_S04` = f1(-0.4),
    `FS03_S04` = f1(-0.2),
    `FS04_S04` = f1(0.1),
    `FS05_S04` = f1(-0.2),
    `FS06_S04` = f1(-0.2),
    `FS07_S04` = f1(0.1),
    `FS08_S04` = f1(-0.5),
  
     # to S03 - Antidiabetic
    `FS00_S03` = f1(-0.1),
    `FS01_S03` = f1(-0.1),
    `FS02_S03` = f1(0.0),
    `FS03_S03` = f1(0.1),
    `FS04_S03` = f1(+0.1),
    `FS05_S03` = f1(+0.2),
    `FS06_S03` = f1(-0.1),
    `FS07_S03` = f1(0.1),
    `FS08_S03` = f1(-0.3),
  
     # to S02 - Biguanide
    `FS00_S02` = f1(0.1),
    `FS01_S02` = f1(0.1),
    `FS02_S02` = f1(0.0),
    `FS03_S02` = f1(0.0),
    `FS04_S02` = f1(0.0),
    `FS05_S02` = f1(0.3),
    `FS06_S02` = f1(-0.1),
    `FS07_S02` = f1(0.2),
    `FS08_S02` = f1(-0.1),
    
     # to S01 - Lapsed
    `FS00_S01` = f1(0.0),
    `FS01_S01` = f1(0.0),
    `FS02_S01` = f1(0.1),
    `FS03_S01` = f1(0.1),
    `FS04_S01` = f1(0.2),
    `FS05_S01` = f1(0.2),
    `FS06_S01` = f1(0.1),
    `FS07_S01` = f1(0.0),
    `FS08_S01` = f1(0.0)
  )
}  





    
    

# Combine both scenario components
#levers <- baseCase
levers <- append(baseCase, F10Launch)

# Definite lifetime of S10, other stocks retain historic lifetimes
lifetimes <- model$summary$lifetime
lifetimes[9] <- 10
# Simulate model
m <- modelUpdate(model,
                 lifetimes    = lifetimes,
                 levers       = levers, 
                 showLevers   = FALSE,
                 applyLevers  = TRUE,
                 debug        = FALSE
                 )
# Plot stocks
modelPlotEntities(model, entities = "stocks", mfrow=c(4,3))

# Plot all flow values
modelPlotFlowGrid(model          = model,
                  globalScaling  = FALSE,
                  showFlowShares = "inflow")
# 
# # Plot share of outflows
# modelPlotFlowGrid(model          = model,
#                   globalScaling  = FALSE,
#                   showFlowShares = "inflow"
#                   )
# modelPlotFlowGrid(model          = model,
#                   globalScaling  = FALSE,
#                   showFlowShares = "outflow"
#                   )

temp <- model$data
temp[grepl("_S10",entity),c(1,163)]
sum(temp[grepl("_S10",entity),c(163)])
temp[grepl("_S10",entity),c(163)]/sum(temp[grepl("_S10",entity),c(163)]) 

```

# Ad hoc analysis

```{r}

en <- setdiff(model$en$stocks$id, c("S00", "S01"))
a <- as.matrix(model$data[entity %in% en,5:ncol(model$data)],)

y <- apply(a,2, cumsum)/1000
matplot(t(y),type="l", lty=1, lwd=2, las=1, ylab="", xlab="", ylim=c(0,max(y)))
abline(v=60)

yl <- diff(c(0,y[,ncol(y)])/2) + c(0,y[1:(nrow(y)-1),ncol(y)])
text(x=115, y=yl, en)

```

